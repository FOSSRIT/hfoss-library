<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Bug Tracker</title><link rel="stylesheet" type="text/css" href="styles.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="Producing Open Source Software"><link rel="up" href="technical-infrastructure.html" title="Chapter 3. &#2980;&#3014;&#3006;&#2996;&#3007;&#2994;&#3021;&#2984;&#3009;&#2975;&#3021;&#2986; &#2953;&#2995;&#3021;&#2965;&#2975;&#3021;&#2975;&#2990;&#3016;&#2986;&#3021;&#2986;&#3009;"><link rel="prev" href="vc.html" title="Version Control"><link rel="next" href="irc.html" title="IRC / Real-Time Chat Systems"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Bug Tracker</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="vc.html">Prev</a> </td><th width="60%" align="center">Chapter 3. &#2980;&#3014;&#3006;&#2996;&#3007;&#2994;&#3021;&#2984;&#3009;&#2975;&#3021;&#2986; &#2953;&#2995;&#3021;&#2965;&#2975;&#3021;&#2975;&#2990;&#3016;&#2986;&#3021;&#2986;&#3009;</th><td width="20%" align="right"> <a accesskey="n" href="irc.html">Next</a></td></tr></table><hr></div><div class="sect1" title="Bug Tracker"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bug-tracker"></a>Bug Tracker</h2></div></div></div><p>Bug tracking is a broad topic; various aspects of it are
discussed throughout this book.  Here I'll concentrate mainly on the
features your project should look for in a bug tracker, and how to use
them.  But to get to those, we have to start with a policy question:
exactly what kind of information should be kept in a bug
tracker?</p><p>The term <em class="firstterm">bug tracker</em> is misleading.  Bug
tracking systems are used to track not only bug reports, but new
feature requests, one-time tasks, unsolicited patches&#8212;really
anything that has distinct beginning and end states, with optional
transition states in between, and that accrues information over its
lifetime.  For this reason, bug trackers are also called
<em class="firstterm">issue trackers</em>, <em class="firstterm">ticket
trackers</em>, <em class="firstterm">defect trackers</em>,
<em class="firstterm">artifact trackers</em>, <em class="firstterm">request
trackers</em>, etc.</p><p>In this book, I'll generally use the word
<em class="firstterm">ticket</em> to refer the items in the tracker's
database, because that distinguishes between the behavior that the
user encountered or proposed &#8212; that is, the bug or
feature itself &#8212; and the tracker's ongoing
<span class="emphasis"><em>record</em></span> of that discovery, diagnosis, discussion,
and eventual resolution.  But note that many projects use the word
<span class="emphasis"><em>bug</em></span> or <span class="emphasis"><em>issue</em></span> to refer to
both the ticket itself and to the underlying behavior or goal that the
ticket is tracking.  (In fact, those usages are probably more common than
"ticket"; it's just that in this book we need to be able to make that
distinction explicitly in a way that projects themselves usually
don't.)</p><p>The classic ticket life cycle looks like this:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Someone files the ticket.  They provide a summary, an
            initial description (including a reproduction recipe, if
            applicable; see
            <a class="xref" href="managing-volunteers.html#users-to-volunteers" title="Treat Every User as a Potential Volunteer">the section called &#8220;Treat Every User as a Potential Volunteer&#8221;</a><span> in
            <a class="xref" href="managing-volunteers.html" title="Chapter 8. Managing Volunteers">Chapter 8, <i>Managing Volunteers</i></a></span> for
            how to encourage good bug reports), and whatever other
            information the tracker asks for.  The person who files
            the ticket may be totally unknown to the project&#8212;bug
            reports and feature requests are as likely to come from
            the user community as from the developers.</p><p>Once filed, the ticket is in what's called an
            <em class="firstterm">open</em> state.  Because no action has
            been taken yet, some trackers also label it as
            <em class="firstterm">unverified</em> and/or
            <em class="firstterm">unstarted</em>.  It is not assigned to
            anyone; or, in some systems, it is assigned to a fake
            user to represent the lack of real assignation.  At this
            point, it is in a holding area: the ticket has been
            recorded, but not yet integrated into the project's
            consciousness.</p></li><li class="listitem"><p>Others read the ticket, add comments to it, and
            perhaps ask the original filer for clarification on some
            points.</p></li><li class="listitem"><p>The bug gets <em class="firstterm">reproduced</em>.
            This may be the most important moment in its
            life cycle.  Although the bug is not actually fixed yet,
            the fact that someone besides the original filer was able
            to make it happen proves that it is genuine, and, no less
            importantly, confirms to the original filer that they've
            contributed to the project by reporting a real bug.
            <span class="emphasis"><em>(This step and some of the others don't apply to
            feature proposals, task tickets, etc, of course.  But most
            filings are for genuine bugs, so we'll focus on that
            here.)</em></span></p></li><li class="listitem"><p>The bug gets <em class="firstterm">diagnosed</em>: its
            cause is identified, and if possible, the effort required
            to fix it is estimated.  Make sure these things get
            recorded in the ticket; if the person who diagnosed the
            bug suddenly has to step away from it for a
            while, someone else should be able to pick up where she
            left off.</p><p>In this stage, or sometimes in the previous one,
            a developer may "take ownership" of the ticket and
            <em class="firstterm">assign</em> it to herself (<a class="xref" href="managing-volunteers.html#delegation-assignment" title="Distinguish clearly between inquiry and assignment">the section called &#8220;Distinguish clearly between inquiry and assignment&#8221;</a><span> in
            <a class="xref" href="managing-volunteers.html" title="Chapter 8. Managing Volunteers">Chapter 8, <i>Managing Volunteers</i></a></span>
            examines the assignment process in more detail).  The ticket's
            <em class="firstterm">priority</em> may also be set at this
            stage.  For example, if it is so important that it should
            delay the next release, that fact needs to be identified
            early, and the tracker should have some way of noting
            it.</p></li><li class="listitem"><p>The ticket gets scheduled for resolution.
            Scheduling doesn't necessarily mean naming a date by which
            it will be fixed.  Sometimes it just means deciding which
            future release (not necessarily the next one) the bug
            should be fixed by, or deciding that it need not block any
            particular release.  Scheduling may also be dispensed
            with, if the bug is quick to fix.</p></li><li class="listitem"><p>The bug gets fixed (or the task completed, or
            the patch applied, or whatever).  The change or set of
            changes that fixed it should be discoverable from
            the ticket.  After this, the ticket is
            <em class="firstterm">closed</em> and/or marked as
            <em class="firstterm">resolved</em>.</p></li></ol></div><p>

</p><p>There are some common variations on this life cycle.  Sometimes
a ticket is closed very soon after being filed, because it turns out
not to be a bug at all, but rather a misunderstanding on the part of
the user.  As a project acquires more users, more and more such
invalid tickets will come in, and developers will close them with
increasingly short-tempered responses.  Try to guard against the
latter tendency.  It does no one any good, as the individual user in
each case is not responsible for all the previous invalid tickets; the
statistical trend is visible only from the developers' point of view,
not the user's.  (In
<a class="xref" href="bug-tracker.html#bug-filtering" title="Pre-Filtering the Bug Tracker">the section called &#8220;Pre-Filtering the Bug Tracker&#8221;</a><span> later
in this chapter,</span> we'll look at
techniques for reducing the number of invalid tickets.)  Also, if
different users are experiencing the same misunderstanding over and
over, it might mean that aspect of the software needs to be
redesigned.  This sort of pattern is easiest to notice when there is
an issue manager monitoring the bug database; see
<a class="xref" href="share-management.html#issue-manager" title="Issue Manager">the section called &#8220;Issue Manager&#8221;</a><span> in
<a class="xref" href="managing-volunteers.html" title="Chapter 8. Managing Volunteers">Chapter 8, <i>Managing Volunteers</i></a></span>.</p><p>Another common life event for the ticket to be closed
as a <em class="firstterm">duplicate</em> soon after Step 1.  A duplicate
is when someone reports something that's already known to the project.
Duplicates are not confined to open tickets: it's possible for a bug to
come back after having been fixed (this is known as a
<em class="firstterm">regression</em>), in which case a reasonable course
is to reopen the original ticket and close any new reports as
duplicates of the original one.  The bug tracking system should keep
track of this relationship bidirectionally, so that reproduction
information in the duplicates is available to the original ticket, and
vice versa.</p><p>A third variation is for the developers to close the ticket,
thinking they have fixed it, only to have the original reporter reject
the fix and reopen it.  This is usually because the developers simply
don't have access to the environment necessary to reproduce the bug,
or because they didn't test the fix using the exact same reproduction
recipe as the reporter.</p><p>Aside from these variations, there may be other small details of
the life cycle that vary depending on the tracking software.  But the
basic shape is the same, and while the life cycle itself is not
specific to open source software, it has implications for how open
source projects use their bug trackers.</p><p>The tracker is as much a public face of the project as the
mailing lists or web pages.  Anyone may file a ticket, anyone may look
at a ticket, and anyone may browse the list of currently open tickets.
It follows that you never know how many people are waiting to see
progress on a given ticket.  While the size and skill of the
development community constrains the rate at which tickets can be
resolved, the project should at least try to acknowledge each ticket
the moment it appears.  Even if the ticket lingers for a while, a
response encourages the reporter to stay involved, because she feels
that a human has registered what she has done (remember that filing a
ticket usually involves more effort than, say, posting an email).
Furthermore, once a ticket is seen by a developer, it enters the
project's consciousness, in the sense that the developer can be on the
lookout for other instances of the ticket, can talk about it with
other developers, etc.</p><p>This centrality to the life of the project implies a few things
about trackers' technical features:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The tracker should be connected to email, such that
    every change to a ticket, including its initial filing, causes a
    notification mail to go out to some set of appropriate
    recipients.  See <a class="xref" href="bug-tracker.html#bug-tracker-email-interaction" title="Interaction with Email">the section called &#8220;Interaction with Email&#8221;</a>
    later in this chapter for more on this.</p></li><li class="listitem"><p>The form for filing tickets should have a place to record
    the reporter's email address or other contact information, so she
    can be contacted for more details.  But if possible, it should not
    <span class="emphasis"><em>require</em></span> the reporter's email address or real
    identity, as some people prefer to report anonymously.  See <a class="xref" href="web-site.html#anonymity" title="&#2949;&#2993;&#3007;&#2991;&#2986;&#3021;&#2986;&#2975;&#3006;&#2980; &#2952;&#2975;&#3009;&#2986;&#3006;&#2975;&#3009;">the section called &#8220;&#2949;&#2993;&#3007;&#2991;&#2986;&#3021;&#2986;&#2975;&#3006;&#2980; &#2952;&#2975;&#3009;&#2986;&#3006;&#2975;&#3009;&#8221;</a><span> later in this
    chapter</span> for more on the importance of anonymity.</p></li><li class="listitem"><p>The tracker should have APIs.  I cannot stress the
    importance of this enough.  If there is no way to interact with
    the tracker programmatically, then in the long run there is no way
    to interact with it scalably.  APIs provide a route to customizing
    the behavior of the tracker by, in effect, expanding it to include
    third-party software.  Instead of being just the specific ticket
    tracking software running on a server somewhere, it's that
    software <span class="emphasis"><em>plus</em></span> whatever custom behaviors your
    project implements elsewhere and plugs in to the tracker via the
    APIs.</p><p>Also, if your project uses a proprietary ticket tracker,
    as is becoming more common now that so many projects host their
    code on proprietary-but-free-of-charge hosting sites and just use
    the site's built-in tracker, APIs provide a way to avoid being
    locked in to that hosting platform.  You can, in theory, take the
    ticket history with you if you choose to go somewhere else (you
    may never exercise this option, but think of it as
    insurance &#8212; and some projects have actually done
    it).</p><p>Currently, the ticket trackers of the big three hosting
    sites (GitHub, Google Code Hosting, and SourceForge) all have
    APIs, fortunately.  Of them, only SourceForge is itself open
    source, running a platform called
    <em class="firstterm">Allura</em><sup>[<a name="idp6720992" href="#ftn.idp6720992" class="footnote">31</a>]</sup>.</p></li></ul></div><p>

</p><div class="sect2" title="Interaction with Email"><div class="titlepage"><div><div><h3 class="title"><a name="bug-tracker-email-interaction"></a>Interaction with Email</h3></div></div></div><a name="bug-tracker-mailing-list-interaction"></a><p>Most trackers now have at least decent email integration
features: at a minimum, the ability to create new tickets by email,
the ability to "subscribe" to a ticket to receive
emails about activity on that ticket, and the ability to add new
comments to a ticket by email.  Some trackers even allow one to
manipulate ticket state (e.g., change the status field, the assignee,
etc) by email, and for people who use the tracker a lot, such as an
<a class="xref" href="share-management.html#issue-manager" title="Issue Manager">the section called &#8220;Issue Manager&#8221;</a>, that can make a
huge difference in their ability to stay on top of tracker activity
and keep things organized.</p><p>The tracker email feature that is likely to be used by everyone,
though, is simply the ability to read a ticket's activity by email and
respond by email.  This is a valuable time-saver for many people in
the project, since it makes it easy to integrate bug traffic into
one's daily email flow.  But don't let this integration give
anyone the illusion that the total collection of bug tickets and their
email traffic is the equivalent of the development mailing list.  It's
not, and <a class="xref" href="">???</a><span>
in <a class="xref" href="communications.html" title="Chapter 6. Communications">Chapter 6, <i>Communications</i></a></span> discusses why this is
important and how to manage the difference.</p></div><div class="sect2" title="Pre-Filtering the Bug Tracker"><div class="titlepage"><div><div><h3 class="title"><a name="bug-filtering"></a>Pre-Filtering the Bug Tracker</h3></div></div></div><p>Most ticket databases eventually suffer from the same problem: a
crushing load of duplicate or invalid tickets filed by well-meaning but
inexperienced or ill-informed users.  The first step in combatting
this trend is usually to put a prominent notice on the front page of
the bug tracker, explaining how to tell if a bug is really a bug, how
to search to see if it's already been reported, and finally, how to
effectively report it if one still thinks it's a new bug.</p><p>This will reduce the noise level for a while, but as the number
of users increases, the problem will eventually come back.  No
individual user can be blamed for it.  Each one is just trying to
contribute to the project's well-being, and even if their first bug
report isn't helpful, you still want to encourage them to stay
involved and file better tickets in the future.  In the meantime,
though, the project needs to keep the ticket database as free of junk
as possible.</p><p>The two things that will do the most to prevent this problem
are: making sure there are people watching the bug tracker who have
enough knowledge to close tickets as invalid or duplicates the moment
they come in, and requiring (or strongly encouraging) users to confirm
their bugs <span class="emphasis"><em>with other people</em></span> before filing them
in the tracker.</p><p>The first technique seems to be used universally.  Even projects
with huge ticket databases (say, the Debian bug tracker at
<a class="ulink" href="http://bugs.debian.org/" target="_top">bugs.debian.org</a>, which
contained 739,542 tickets as of this writing) still arrange things so that
<span class="emphasis"><em>someone</em></span> sees each ticket that comes in.  It may be
a different person depending on the category of the ticket.  For
example, the Debian project is a collection of software packages, so
Debian automatically routes each ticket to the appropriate package
maintainers.  Of course, users can sometimes misidentify a ticket's
category, with the result that the ticket is sent to the wrong person
initially, who may then have to reroute it.  However, the important
thing is that the burden is still shared&#8212;whether the user
guesses right or wrong when filing, ticket watching is still
distributed more or less evenly among the developers, so each ticket is
able to receive a timely response.</p><p>The second technique is less widespread, probably because it's
harder to automate.  The essential idea is that every new ticket gets
"buddied" into the database.  When a user thinks he's found a problem,
he is asked to describe it on one of the mailing lists, or in an IRC
channel, and get confirmation from someone that it is indeed a bug.
Bringing in that second pair of eyes early can prevent a lot of
spurious reports.  Sometimes the second party is able to identify that
the behavior is not a bug, or is fixed in recent releases.  Or she may
be familiar with the symptoms from a previous ticket, and can prevent a
duplicate filing by pointing the user to the older ticket.  Often it's
enough just to ask the user "Did you search the bug tracker to see if
it's already been reported?"  Many people simply don't think of that,
yet are happy to do the search once they know someone's
<span class="emphasis"><em>expecting</em></span> them to.</p><p>The buddy system can really keep the ticket database clean, but
it has some disadvantages too.  Many people will file solo anyway,
either through not seeing, or through disregarding, the instructions
to find a buddy for new tickets.  Thus it is still necessary for
volunteers to watch the ticket database.  Furthermore, because most new
reporters don't understand how difficult the task of maintaining the
ticket database is, it's not fair to chide them too harshly for
ignoring the guidelines.  Thus the volunteers must be vigilant, and
yet exercise restraint in how they bounce unbuddied tickets back to
their reporters.  The goal is to train each reporter to use the
buddying system in the future, so that there is an ever-growing pool
of people who understand the ticket-filtering system.  On seeing an
unbuddied ticket, the ideal steps are:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Immediately respond to the ticket, politely thanking the user
          for filing, but pointing them to the buddying guidelines
          (which should, of course, be prominently posted on the web
          site).</p></li><li class="listitem"><p>If the ticket is clearly valid and not a duplicate, approve it
          anyway, and start it down the normal life cycle.  After all,
          the reporter's now been informed about buddying, so there's
          no point closing a valid ticket and wasting the work done so
          far.</p></li><li class="listitem"><p>Otherwise, if the ticket is not clearly valid, close it, but
          ask the reporter to reopen it if they get confirmation from
          a buddy.   When they do, they should put a reference to the
          confirmation thread (e.g., a URL into the mailing list
          archives).</p></li></ol></div><p>Remember that although this system will improve the signal/noise
ratio in the ticket database over time, it will never completely stop
the misfilings.  The only way to prevent misfilings entirely is to
close off the bug tracker to everyone but developers&#8212;a cure that
is almost always worse than the disease.  It's better to accept that
cleaning out invalid tickets will always be part of the project's
routine maintenance, and to try to get as many people as possible to
help.</p><p>See also
<a class="xref" href="share-management.html#issue-manager" title="Issue Manager">the section called &#8220;Issue Manager&#8221;</a><span> in
<a class="xref" href="managing-volunteers.html" title="Chapter 8. Managing Volunteers">Chapter 8, <i>Managing Volunteers</i></a></span>.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.idp6720992" href="#idp6720992" class="para">31</a>] </sup>Oddly, SourceForge's
    API was also the hardest to find documentation for, though it
    helps once you know the platform's name is "Allura".  For
    reference, their API documentation is here: <a class="ulink" href="http://sourceforge.net/p/forge/documentation/Allura%20API/" target="_top">sourceforge.net/p/forge/documentation/Allura%20API</a></p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="vc.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="technical-infrastructure.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="irc.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Version Control </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> IRC / Real-Time Chat Systems</td></tr></table></div></body></html>
