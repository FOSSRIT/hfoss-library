<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chương 7. Đóng gói, Phân phối và Phát triển hàng ngày</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="chapter" title="Chương 7. Đóng gói, Phân phối và Phát triển hàng ngày"><div class="titlepage"><div><div><h1 class="title"><a id="development-cycle"/>Chương 7. Đóng gói, Phân phối và Phát triển hàng ngày</h1></div></div></div><div class="simplesect"><div class="titlepage"/><p>Chương này trình bày về vấn đề đóng gói dự án phần mềm 
và phát hành phần mềm, và những loại phát triển chung xung quanh 
mục đích dự án.</p><p>Sự khác biệt giữa phần mềm mã mở và phần mềm bản quyền là sự quản lý
tập trung đối với đội ngũ phát triển.</p><p>Khi chuẩn bị một phiên bản mới, sự khác biệt này là đặc biệt
rõ rệt: một công ty có thể yêu cầu toàn bộ đội ngũ phát triển tập trung vào
một bản phát hành sắp tới, đặt sang một bên tính năng mới và phát triển
không quan trọng sửa lỗi cho đến khi phát hành xong.</p><p>Nhóm tình nguyện viên không phải là một "khối" cứng. 
Mọi người tham gia dự án vì nhiều lý do khác nhau, 
và những người quan tâm tới một bản phát hành cho
vẫn muốn tiếp tục công việc phát triển thường xuyên, liên tiếp dù bản đó đã ra đời. 
Vì tính phát triển không ngừng của dự án mã nguồn mở, phát hành mã nguồn mở
quy trình có xu hướng tốn nhiều thời gian, nhưng ít gây rối, 
so với các quy trình phát hành thương mại. 
Điều đó cũng giống như việc sửa đường cao tốc. 
Có hai cách để sửa chữa một con đường: bạn có thể chặn hoàn toàn đường, 
sửa chữa hết công suất cho đến khi vấn đề đượcgiải quyết, 
hoặc bạn có thể làm việc trên một số tuyến đường tại một thời điểm, 
tuy vẫn mở các đoạn đường khác</p><p>Cách đầu tiên là rất hiệu quả <span class="emphasis"><em> với đội thợ </em></span>, 
nhưng nó không cho bất cứ ai khác sử dụng đường cho đến khi việc sửa hoàn thành. 
Cách làm thứ hai cần
nhiều thời gian và rắc rối cho đội thợ (bây giờ họ phải làm việc
ít người hơn và trang thiết bị ít hơn, trong điều kiện chật hẹp,
tiến hành chậm do lưu lượng truy cập trực tiếp, vv), nhưng ít nhất thì đường
vẫn sử dụng được, mặc dù không hết công suất.</p><p>
Dự án mã nguồn mở có xu hướng làm việc theo cách thứ hai. Trong thực tế, 
cho một đoạn mã nguồn ổn định đựoc duy trì đồng thời, 
dự án sẽ rơi vào tình trạng luôn phải 
sửa chữa những đoạn đường nhỏ. Luôn luôn có một vài làn bị chặn 
phù hợp nhưng mức độ bất tiện thấp. Việc sửa chữa đó được
chấp nhận bởi nhóm phát triển nói chung sao cho có được bản phát hành
theo đúng lịch trình.
</p><p>
Mô hình mà làm này có thể tổng quát hóa từ việc
phát hành. Đó là nguyên tắc làm việc song song không
làm hai bên phụ thuộc lẫn nhau-một nguyên tắc là không có nghĩa là duy nhất
để phát triển nguồn mở. Tất nhiên, nhưng dự án nguồn mở
được thực hiện theo cách đặc biệt của riêng nó. Họ không thể
gây phiền toái quá nhiều tới luồng giao thông, 
nhưng họ cũng không thể đứng chắn đường
và làm luồng giao thông suy giảm theo. Do đó, họ tạo ra một 
quy trình phẳng với các cấp độ quản lý đồng cấp, không có người hơn, người kém.
Các tình nguyện viên nói chung sẽ sẵn sàng
làm việc với sự bất tiện nhỏ nhưng thích hợp; 
tính có thể dự báo cho phép họ đi đến đích mà không lo lắng về
lịch trình và những khúc mắc xảy ra trong
dự án. 
Nhưng nếu các dự án được đặt dưới một lình trình cứng trong đó
một số hoạt động không cho phép một số họat động khác tiến hành, kết quả sẽ là một hay 
rất nhiều nhà phát triển không có việc gì làm (phải đợi), làm phí phạm thời gian-điều 
đó không những không hiệu quả mà còn nhàm chán, và do đó là nguy hiểm. 
Và một khi một lập trình viên cảm thấy nhàm chán, họ sẽ bỏ dự án
</p><p>
Công việc phát hành thường không phải là công việc đáng chú ý nhất trong quy trình phát triển phần mềm.
Điều đó xảy ra song song với sự phát triển, do đó, các phương pháp mô tả trong
các phần sau chủ yếu hướng tới sự phát hành liên tục suôn sẻ.
Tuy nhiên, lưu ý rằng những điều này cũng áp dụng cho các nhiệm vụ son song khác, 
chẳng hạn như bản dịch hay quốc tế hóa, thay đổi API diện rộng sẽ 
dần dẫn tới sự thay đổi toàn bộ mã nguồn...
</p></div><div class="sect1" title="Đánh số phát hành"><div class="titlepage"><div><div><h1 class="title"><a id="release-numbering"/>Đánh số phát hành</h1></div></div></div><p>Trước khi nói về việc làm thế làm để phát hành,
chúng ta hãy xem tên bản phát hành có ý nghĩa như thế nào đối với người dùng cuối.
Phát hành bao gồm:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Sửa lỗi cũ. Đây là điều mà người dùng mong đợi ở mọi phiên bản phát hành.</p></li><li class="listitem"><p>Thêm lỗi mới. Phát hành bao gồm cả những lỗi kèm theo trừ những phiên bản phát 
                  hành một lần duy nhất vì lý do bảo mật(xem
            <a class="xref" href="ch07s06.html#security-releases" title="Security Releases">phần “Security Releases”</a><span> trong chương sau.</span>).</p></li><li class="listitem"><p>Thêm chức năng mới.</p></li><li class="listitem"><p>Thêm chức năng cấu hình mới, hoặc có sự thay đổi ý nghĩa của cấu hình cũ.
   Có thể có cả sự thay đổi thứ tự cài đặt nhưng nói chung nên tránh điều này.</p></li><li class="listitem"><p>Những thay đổi phá vỡ sự tương thích,
   ví dụ như thay đổi cấu trúc dữ liệu làm cho phiên bản cũ và mới không thể sử dụng đồng thời nếu không
   hoán chuyển định dạng dữ liệu.</p></li></ul></div><p>
Như bạn thấy, không phải tất cả những điều này là tốt đẹp. Đây là lý do tại sao những
người dùng có kinh nghiệm tiếp cận phiên bản mới với một số lo lắng,
đặc biệt là khi phần mềm là trưởng thành và đã thỏa mãn những yêu cầu
họ muốn mong muốn (hoặc nghĩ rằng họ muốn). Ngay cả sự xuất hiện của mới
tính năng là một tín hiệu hỗn hợp, trong đó nó có thể có nghĩa là các phần mềm
bây giờ sẽ cư xử một cách không thể lường trước.
</p><p>
Mục đích của việc đánh số phát hành, do đó, gồm hai phần:
rõ ràng là những con số rõ ràng nên giao tiếp thứ tự của
phát hành (tức là, bằng cách nhìn vào con số bất kỳ hai phiên bản, người ta có thể biết
đâu là bản mới, cũ), ngoài ra, số phiên bản còn thể hiện
mức độ và tính chất của những thay đổi trong việc phát hành.
</p><p>Thể hiển tất cả những điều đó trong số phiên bản?
Cũng được, và chỉ là vậy thôi. Đánh số phiên bản là một trong những chủ đề
nhỏ nhặt nhưng được tranh luận nhiều nhất từ trước tới nay
(xem <a class="xref" href="ch06s02.html#bikeshed" title="The Softer the Topic, the Longer the Debate">phần “The Softer the Topic, the Longer the Debate”</a><span> trong
<a class="xref" href="ch06.html" title="Chương 6. Communications">Chương 6, <em>Communications</em></a></span>), 
và hiện nay, thế giới vẫn chưa thống nhất về một chuẩn đánh số duy nhất.
Tuy nhiên, có một số chiến lược đánh số được số đông đồng tình theo nguyên tắc:
<span class="emphasis"><em>Thống nhất</em></span>.
Hãy chọn một chiến lược đánh số, văn bản hóa nó,
tuân thủ chặt chẽ theo nó và người dùng sẽ cảm ơn bạn.</p><div class="sect2" title="Các thành phần của số phiên bản"><div class="titlepage"><div><div><h2 class="title"><a id="release-number-components"/>Các thành phần của số phiên bản</h2></div></div></div><p>
Phần này mô tả các quy ước chính thức phát hành
một cách cụ thể. Chúng ta giả định chúng ta có rất ít thông tin về cách đánh số. 
Điều này chủ yếu có tính tham khảo. Nếu bạn đã quen thuộc với các
quy ước, bạn có thể bỏ qua phần này.
</p><p>Số phiên bản theo chữ số, phân cách bằng dấu chấm:</p><div class="informalexample"><div class="literallayout"><p>Scanley 2.3<br/>
Singer 5.11.4</p></div></div><p> Dấu chấm <span class="emphasis"><em>không</em></span> phải là dấu ngăn cách giữa 
chữ số thập phân và chữ số đơn vị.
Nó chỉ đơn thuần là sự phân cách, "5.3.9" và tiếp theo là
"5.3.10". Một vài dự án có đôi khi gợi ý khác, nhất
hạt nhân Linux nổi tiếng với nó "0.95", "0.96" ... "0.99" và sau đó 
là Linux 1.0, nhưng các quy ước rằng các dấu chấm không
số thập phân hiện đã được và cần được xem xét một
tiêu chuẩn. Không có giới hạn về số lượng các thành phần (chữ số
phần không chứa dấu chấm), nhưng hầu hết các dự án không vượt quá ba
hoặc bốn. Những lý do tại sao sẽ trở nên rõ ràng sau đó.</p><p>Ngoài cách dùng chữ số thành phần,
một vài dự án còn dùng chữ để phân biệt như
"Alpha" hay "Beta" (xem
<a class="xref" href="ch02.html#alpha-and-beta" title="Alpha and Beta">Alpha and Beta</a>), ví dụ:</p><div class="informalexample"><div class="literallayout"><p>Scanley 2.3.0 (Alpha)<br/>
Singer 5.11.4 (Beta)</p></div></div><p>
Một bản "Alpha" hay "Beta" có nghĩa rằng đây là một bản 
<span class="emphasis"><em>tiền chính thức</em></span>, và rằng một bản phát hành trong tương lai sẽ có
cùng một số phiên bản nhưng không kèm theo "Alpha" hay "Beta". 
Như vậy, sau "2.3.0 (Alpha)" sẽ là "2.3.0". Để cho phép một số ứng viên như vậy
phát hành liên tiếp, có thể đặt tên các phiên bản tiền-chính-thức và tiền-tiền-chính-thức.
Ví dụ, đây là một loạt các bản phát hành theo thứ tự mà họ sẽ
được đóng gói sẵn có cho công chúng:
</p><div class="informalexample"><div class="literallayout"><p>Scanley 2.3.0 (Alpha 1)<br/>
Scanley 2.3.0 (Alpha 2)<br/>
Scanley 2.3.0 (Beta 1)<br/>
Scanley 2.3.0 (Beta 2)<br/>
Scanley 2.3.0 (Beta 3)<br/>
Scanley 2.3.0</p></div></div><p>Chú ý rằng khi phiên bản chứa "Alpha", Scanley "2.3" được viết là "2.3.0".  
Hai phiên bản này là tương đương— và để đơn giản, các số không 
thường được bỏ qua—.</p><p>Các hạn định từ khác được dùng bán chính thức là "Stable" (ổn định),
"Unstable" (không ổn định), "Development" (phát triển), và "RC" (for "Release Candidate").  
Hạn định từ hay được dùng nhất là "Alpha" và "Beta", tiếp đó là "RC"
đứng vị trí thứ ba. Tuy nhiên chú ý rằng "RC" luôn chứa một chữ số bán hạn định từ
Nghĩa là, bạn sẽ không phát hành phiên bản 
"Scanley 2.3.0 (RC)", mà là
"Scanley 2.3.0 (RC 1)", tiếp đó là RC2, ...</p><p>Tác giả khuyến nghị sử dụng các từ thông dụng như, "Alpha", "Beta", and "RC", are pretty widely
vì nó được sử dụng rộng rãi và tránh không dùng các từ khác
vì những từ này không phải là "từ lóng" được mọi người khác sử dụng.</p><p>
Dấu chấm ở đây không phải là ký hiệu phân cách giữa số thập phân và 
chữ số sau dấy phảy. Các phiên bản "0.X.Y" sẽ là tiền thân của 
"1.0" (tương đương với "1.0.0").  "3.14.158" là tiền thân kề của 
"3.14.159", và không phải là tiền thân kề của 
"3.14.160" hay "3.15.'số nào đo'".</p><p>
Cần phải có một quy định về đánh số phiên bản vì qua con số này,
người dùng biết được sự khác nhau quan trọng giữa hai phiên bản
chỉ cần nhìn qua số phiên bản.
Trong hệ thống đánh số ba thành phần, thành phần thứ nhất là 
<em class="firstterm">major number</em> (số phiên bản chính), thành phần thứ hai là
<em class="firstterm">minor number</em>, (số phiên bản phụ) và thành phần thứ ba là
<em class="firstterm">micro number</em> (số micro).  
Ví dụ, "2.10.17" là phiên bản micro thứ 17 của chuỗi phiên bản phụ thứ 10 
trong dòng phiên bản chính số 2. Từ "dòng" (line) và "chuỗi" (series) ở 
đây được dùng không chính thức, nhưng ý nghĩa của nó giống như bạn đang đọc.
Một chuỗi phiên bản chính đơn giản là các phiên bản có cùng số phiên bản chính,
một chuỗi (phiên bản) phụ bao gồm các phiên bản có cùng số phiên bản phụ <span class="emphasis"><em>và</em></span>
số phiên bản chính. Nghĩa là, "2.4.0" và "3.4.1" không cùng số phiên bản chính
mặc dù số phiên bản phụ giống nhau ("4").
"2.4.0" và "2.4.2" nằm cùng dòng phiên bản chính và phiên bản phụ mặc dù chúng
không nắm kế tiếp nhau (2.4.1 là kế tiếp của 2.4.0).</p><p>Ý nghĩ của các con số này giống như những gì bạn đọc dược:
Nếu số phiên bản chính tăng một nghĩa là có thay đối lớn;
nếu số phiên bản phụ tăng một, nghĩa là có thay đổi phụ (nhỏ);
và số phiên bản micro là
<em class="firstterm">patch number</em> (số bản vá),
Chú ý rằng một số dự án dùng số bản giống như số micro,
điều này đôi khi gây nhầm lẫn. Một số dự án khác lại dùng số micro là 
<em class="firstterm">build number</em> (số xây dựng), tăng mỗi lần
khi dự án được "build" (nghĩa là biên dịch lại). 
Điều này có ý nghĩa phân biệt các phiên bản đóng gói cần khi thông báo lỗi.</p><p>
Mặc dù có khá nhiều quy định và thói quen sử dụng các thành phần trong số phiên bản,
nhưng sự khác biệt này là khá tiểu tiết. Hai phần tiếp theo sẽ trình bày về 
một số quy ước được sử dụng rộng rãi.</p></div><div class="sect2" title="Chiến lược đơn giản"><div class="titlepage"><div><div><h2 class="title"><a id="release-number-simple-strategy"/>Chiến lược đơn giản</h2></div></div></div><p>
Hầu hết các dự án có luật về việc cho phép loại thay đổi vào vào một
lần xuất bản nếu nó chỉ chứa một số micro và có luật khác cho số minor, 
và thậm chí khác hơn nữa cho số phiên bản chính. 
Không có "chuẩn" chung đặt cho các luật này nhưng ở đây, chúng tôi 
sẽ mô tả chính sách được dùng thành một ở nhiều dự án.
Bạn có thể cải tiến chính sách này cho phù hợp với dự án của mình.
Chính sách dưới đây được sửa đổi từ dự án APR, xem 
<a class="ulink" href="http://apr.apache.org/versioning.html">http://apr.apache.org/versioning.html</a>.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>
  
  Chỉ thay đổi số micro (nghĩa là, thay đổi trong cùng dòng) phải tương thích với 
  phiên bản trước và sau nó. Nghĩa là, thay đổi này có thể là bug fix, 
  hoặc thay đổi rất nhỏ tới các chức năng sẵn có. Và, chức năng mới không được
  đưa vào phiên bản micro. 
			</p></li><li class="listitem"><p>
  
  
  Thay đổi tới số minor (nghĩa là, thay đổi trong dòng chính), phải thỏa mãn
  tính tương tích với phiên bản trước đó, nhưng không cần thiết tương thích với
  phiên bản sau nó. Thường người ra thêm các chức năng mới vào phiên bản minor,
  			</p></li><li class="listitem"><p>
  Thay đổi số phiên bản chính là ranh giới đánh dấu sự tương thích.
  Một phiên bản chính có thể không tương thích với bản cũ và mới. 
  Một phiên bản chính thường có nhiều chức năng mới, được gộp thành một bộ.
			</p></li></ol></div><p><em class="firstterm">Tương thích ngược (backward-compatible)</em> là gì
phụ thuộc vào việc bản thân phần mềm đó làm gì nhưng thông thường, nó không 
nói lên nhiều điều. Ví dụ, nếu chương trình của bạn ở dạng máy trạm/máy chủ,
"tương thích ngược" sẽ có nghĩa là, nếu nâng cấp máy chủ lên 2.6.0
không được glàm cho phiên bản 2.5.4 ở máy trạm mất một chức năng bất kỳ
hoặc chạy khác với phiên bản trước đó (trừ trường hợp sửa lỗi!)
Mặt khác, nếu nâng cấp máy trạm lên 2.6.0 cùng với máy chủ, thì máy trạm
sẽ có thêm chức năn mới nhưng bản 2.5.4 lại không sử dụng được chức năng mới này.
Nếu điều đó xảy ra, chúng ta gọi bản nâng cấp là <span class="emphasis"><em>không</em></span>
"tương thích xuôi": Hiển nhiên, bạn không thể hạ phiên bản của máy trạm về 
2.5.4 và giữ mọi chức năng mà nó có ở 2.6.0, vì một số chức năng đó đã đuợc
thêm mới ở 2.6.0.
</p><p>
Điều này nghĩa là bản nâng cấp micro chỉ cần thiết chỉ trong trường hợp sửa lỗi.
Nó phải giữ tính tương thích cả hai hướng: Nếu nâng cấp từ 2.5.3 lên 2.5.4 và sau đó
quay ngược trở lại 2.5.3 thì vẫn không mất chức năng nào. 
Tất nhiên, những bản sửa lỗi với 2.5.4 xuất hiện sau khi hạ phiên bản, nhưng bạn không
mất bất kì sức năng nào, ngoại trừ những lỗi đã được sửa làm ảnh hưởng đến 
một số chức năng có sẵn.
</p><p>
Mô hình máy chủ/máy trạm và một trong những  ví dụ về tính tương thích.
Một ví dụ khác là định dạng dữ liệu: Dữ liệu cần ghi vĩnh cửu hay không?
Nếu cần, phải có một hướng dẫn và chính sách cụ thể để đảm bảo tính tương thích
sao cho phiên bản định dạng 2.6.0 và 2.5.4 tương thích với nhau.
Nếu một chương trình cung cấp API dưới dạng một framework, nó cũng cần tính tương
thích giữa các thư viện cũ và mới.</p><p>
Trong những hệ thống như vậy, chúng ta không có cơ hội đập bỏ tất cả
và bắt đầu lại tư đầu trừ khi bắt đầu phát triển với 
một dòng phiên bản mới. Điều này khá tiện lợi:
Chúng ta sẽ thiết kế lại, thêm chức năng, thay đổi giao thức
so với phiên bản cũ. Thực ra không có giải pháp nhanh chóng nhiệm màu nào
cho bài toán này trừ khi chúng ta thiết kế mở rộng lại từ đầu (đây là một 
đề tài rộng, đáng để viết riêng một quyển sách). 
Chúng ta cũng cần công bố một chính sách về tương thích (ngay cả với
những người đã quen thuộc với khái niệm này) khi công bố 
phần mềm, điều này không thể tránh khỏi. 

</p><p>
Cá quy định trên được ngầm định rằng nó không được áp dụng cho 
những phiên bản trước 1.0, ví dụ như 0.1, 0.2, 0.3...
Sự thay đổi giữa các phiên bản  trước 1.0 là tùy ý. Số phiên bản
trước 1.0 được đánh số bất kỳ tùy theo tác giả, ví dụ 0.1.0, 0.1.1 vân vân...
hoặc cũng có thể không đánh số. 
Các quy định về đánh số phiên bản trước 1.0 khá lỏng lẻo và người ta ngầm
hiểu rằng đây là bản trước-chính-thức và họ "tha thứ" cho sự
thay đổi lớn nhỏ hay không tương thích ngược hay xuôi.</p><p>
Xin lưu ý rằng những điều trên chỉ áp dụng cho hệ số đánh số ba thành phần cụ thể.
Cách đánh số sẽ khác với một hệ thống ba thành phần khác và khác nữa
với hệ thống đánh số hai thành phần. 
Điều quan trọng là cần phải xác định xem ý nghĩa của từng thành phần là gì,
đặt ra quy định và thực hiện chặt chẽ theo quy định đó.</p></div><div class="sect2" title="Chiến lược chẵn/lẻ"><div class="titlepage"><div><div><h2 class="title"><a id="release-number-even-odd-strategy"/>Chiến lược chẵn/lẻ</h2></div></div></div><p>
Một số dự án dùng số chẵn/lẻ để đánh dấu: Số chẵn là ổn định và sổ lẻ
là không ổn định. Các con số này chỉ áp dụng cho số phiên bản minor chứ
không áp dụng cho số phiên bản chính và macro. 
Tăng số micro nghĩa là sửa lỗi (không thêm chức năng mới).
Tăng số phiên bản chính nghĩa là thêm chức năng mới, những thay đổi lớn.</p><p>
Dự án nhân Linux là một ví dụ về cách sử dụng chiến lược chẵn lẻ.
Với cách làm này, họ đưa ra hai dòng sản phẩm ổn định và không ổn định
cho người cần kiểm chứng chức năng mới với mã nguồn mới. 
Ví dụ "2.4.21" là phiên bản ổn định và có thể được khuyến nghị dùng
làm máy chủ web trong khi "2.5.1" là bản không chính thức và chỉ nên
cài vào máy thử nghiệm. Nhóm phát triển xử lý các bản báo lỗi và tăng dần
số micro cho tới khi đạt được độ bão hòa nhất định họ sẽ tăng số minor
và đặt lại số micro là 0; hàm ý rằng đây là phiên bản ổn định.</p><p>
Hệ số đánh số này ít nhất là không xung động với hướng dẫn về tính tương thích
đã trình bày từ trước. Nó đơn thuần chỉ làm overload số minor bằng một số
thông tin khác. Nó bắt số minor tăng gấp hai lần so với số lần cần thiết. 
Chiến lược chẵn/lẻ phù hợp với những dự án có vòng đời phát hành dài 
và hướng tới người dùng cần sự ổn định hơn là chức năng mới. 
Tuy nhiên, đây không là cách duy nhất để phần mềm của chúng ta được
cộng đồng kiểm thảo giúp. 
<a class="xref" href="ch07s03.html" title="Stabilizing a Release">phần “Stabilizing a Release”</a><span>
Trong phần sau của chương này </span> chúng ta sẽ đề cập tới một 
cách đánh số khác, có thể là phổ biến hơn, sao cho mã nguồn chưa-ổn-định
được cộng đồng đón chào hơn. </p></div></div></div></body></html>
