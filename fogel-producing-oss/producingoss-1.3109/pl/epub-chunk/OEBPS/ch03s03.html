<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Kontrola wersji</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="sect1" title="Kontrola wersji"><div class="titlepage"><div><div><h1 class="title"><a id="vc"/>Kontrola wersji</h1></div></div></div><p><em class="firstterm">System kontroli wersji</em> (ang.
    <em class="firstterm">version control system</em> lub <em class="firstterm">revision
        control system</em>) to zestaw narzędzi do śledzenia i
    kontrolowania zmian w plikach projektu, w szczególności w kodzie
    źródłowym, dokumentacji i stronach WWW. Jeśli nigdy nie korzystałeś z
    kontroli wersji, powinieneś jak najprędzej znaleźć kogoś, kto korzystał,
    i przekonać go, aby dołączył do projektu. W dzisiejszych czasach każdy
    spodziewa się, że przynajmniej kod źródłowy projektu znajduje się pod
    kontrolą wersji, i nie traktuje poważnie projektów, które nie korzystają
    z niej przynajmniej minimalnie umiejętnie.</p><p>Kontrola wersji jest tak uniwersalna, ponieważ pomaga praktycznie w
    każdym aspekcie projektu: komunikacji między programistami, zarządzaniu
    wydaniami, śledzeniu błędów, stabilizacji kodu czy eksperymentowaniu,
    może także służyć do uwierzyteniania i przypisywania zasług
    poszczególnym programistom. System kontroli wersji stanowi centralny
    punkt we wszystkich wspomnianych obszarach. Sercem kontroli wersji jest
    <em class="firstterm">zarządzanie zmianami</em>, pozwalające odróżnić każdą
    atomową zmianę w plikach projektu, metadane z nią związane (jak data i
    autor danej zmiany) i przekazać ją do innych użytkowników w sposób, w
    jaki sobie tego zażyczą. To kanał komunikacyjny, w którym podstawową
    jednostką informacji jest pojedyncza zmiana.</p><p>Ten rozdział nie omawia wszystkich aspektów korzystania z systemu
    kontroli wersji. To tak rozległy temat, że przy okazji omawiania innych
    kwestii będziemy do niego wracali jeszcze nie raz w tej książce. Tutaj
    skupimy się na wybraniu i konfiguracji systemu kontroli wersji w taki
    sposób, który wspiera współpracę nad rozwojem projektu.</p><div class="sect2" title="Słownictwo kontroli wersji"><div class="titlepage"><div><div><h2 class="title"><a id="vc-vocabulary"/>Słownictwo kontroli wersji</h2></div></div></div><p>Ta książka nie może nauczyć cię kontroli wersji, jeśli nigdy wcześniej
    z niej nie korzystałeś. Z drugiej strony trudno byłoby rozmawiać o niej
    bez wprowadzenia kilku podstawowych pojęć. Te pojęcia są niezależne od
    konkretnego systemu kontroli wersji, to podstawowe rzeczowniki i
    przymiotniki gdy współpracujemy w sieci, i będą często stosowane w
    dalszej części książki. Nawet gdyby nie wymyślono systemów kontroli
    wersji, problem zarządzania zmianami ciągle by istniał—a więc
    potrzebujemy języka, pozwalającego mówić o problemie w zwięzły sposób.

</p><div class="variablelist"><div class="sidebar" title="Wieloznaczność słowa &quot;wersja&quot;"><a id="version-vs-revision"/><div class="titlepage"><div><div><p class="title"><strong>Wieloznaczność słowa "wersja"</strong></p></div></div></div><p>Słowo wersja jest także używane w kontekście "wersji
      oprogramowania", jak na przykład "wersja 1.0". Należy odróżnić wersję
      w tym znaczeniu, i w znaczeniu systemu kontroli
      wersji<sup>[<a id="idp6241232" href="#ftn.idp6241232" class="footnote">16</a>]</sup>.</p></div><dl><dt><a id="vc-vocabulary-commit"/><span class="term"><em class="firstterm">commit</em></span></dt><dd><p>Dokonać zmiany w projekcie. Bardziej formalnie, zapisać
          zmianę w bazie danych systemu kontroli wersji w taki sposób, że
          może zostać włączona do przyszłych wydań projektu. "Commit" można
          stosować jako czasownik lub rzeczownik<sup>[<a id="idp6213216" href="#ftn.idp6213216" class="footnote">14</a>]</sup>, jako rzeczownik to w
          zasadzie synonim "zmiany". Na przykład: "Właśnie zrobiłem commit
          poprawki dla błędu powodującego problemy ze stabilnością serwera,
          zgłaszanego przez użytkowników Mac OS X. Jay, mógłbyś przejrzeć
          commit i sprawdzić, czy dobrze używam w niej
          alokatora?"</p></dd><dt><a id="vc-vocabulary-log-message"/><span class="term"><em class="firstterm">komentarz do zmiany</em> (ang.
         <em class="firstterm">log message</em>)</span></dt><dd><p>Krótka wiadomość dołączona do każdego commita,
             opisująca jego naturę i cel. Komentarze do zmian to jedne z
             najważniejszych dokumentów każdego projektu, stanowią most
             pomiędzy bardzo technicznym językiem samego kodu, a bardziej
             zorientowanym na użytkownika językiem mówiącym o zadaniach,
             poprawkach błędów i postępie projektu. Dalej w tym rozdziale
             omówimy sposoby dystrybucji komentarzy zmian do odpowiednich
             odbiorców. Co więcej, <a class="xref" href="ch06s04.html#codifying-tradition" title="Codifying Tradition">„Codifying Tradition”</a><span> w
                 <a class="xref" href="ch06.html" title="Rozdział 6. Communications">Rozdział 6, <em>Communications</em></a></span> mówi o tym, jak
             zachęcić uczestników projektu do pisania zwięzłych i
             użytecznych komentarzy do zmian.</p></dd><dt><a id="vc-vocabulary-update"/><span class="term"><em class="firstterm">aktualizacja</em> (ang.
         <em class="firstterm">update</em>)</span></dt><dd><p>Aktualizacja to dołączenie zmian dokonanych przez
             innych do lokalnej kopii projektu, a więc sprawienie, aby kopia
             stała się aktualna. To bardzo częsta czynność, większość
             programistów aktualizuje swój kod wiele razy dziennie, aby mieć
             pewność, że pracują mniej-więcej na tej samej wersji kodu, co
             pozostali. Co więcej, gdy znajdą błąd, mogą być niemal pewni, że
             nie został on jeszcze naprawiony. Na przykład: "Hej,
             zauważyłem, że kod indeksujący zawsze wyrzuca ostatni bajt. Czy
             to nowy błąd?" "Tak, ale został już naprawiony tydzień
             temu—zrób aktualizację, powinien
             zniknąć."</p></dd><dt><a id="vc-vocabulary-repository"/><span class="term"><em class="firstterm">repozytorium</em> (ang.
         <em class="firstterm">repository</em>)</span></dt><dd><p>Baza danych, w której zapisywane są zmiany. Niektóre
             systemy wersji są zcentralizowane: istnieje jedno główne
             repozytorium, przechowujące wszystkie zmiany. Inne są
             zdecentralizowane: każdy programista ma swoje własne
             repozytorium, a zmiany mogą być dowolnie przenoszone pomiędzy
             repozytoriami. System kontroli wersji śledzi zależności
             pomiędzy zmianami, i gdy nadejdzie czas wydania, odpowiedni
             zestaw zmian zostaje zaakceptowany do nowej wersji. Pytanie czy
             lepsze są systemy zcentralizowane czy rozproszone to jedna z
             wciąż żywych programistycznych świętych wojen, postaraj się
             unikać kłótni na ten temat na listach dyskusyjnych
             projektu.</p></dd><dt><a id="vc-vocabulary-checkout"/><span class="term"><em class="firstterm">checkout</em></span></dt><dd><p>Proces pobierania kopii projektu z repozytorium.
          Checkout<sup>[<a id="idp6228880" href="#ftn.idp6228880" class="footnote">15</a>]</sup> zazwyczaj tworzy drzewo podkatalogów,
          nazywane "kopią roboczą" (patrz niżej), w której zmiany mogą być
          wysyłane do repozytorium (jako commit). W niektórych
          zdecentralizowanych systemach kontroli wersji każda kopia robocza
          jest zarazem repozytorium, a zmiany mogą być wypychane z (lub
          wciągane do) każdego repozytorium, które je
          zaakceptuje.</p></dd><dt><a id="vc-vocabulary-working-copy"/><span class="term"><em class="firstterm">kopia robocza</em> (<em class="firstterm">ang. working
             copy</em>)</span></dt><dd><p>Prywatne drzewo katalogów każdego programisty,
             zawierające kod źródłowy projektu i być może jego stronę WWW,
             czy inne dokumenty. Kopia robocza zawiera także pewną ilość
             metadanych, zarządzanych przez system kontroli wersji,
             określających z jakiego repozytorium pochodzi, jakie "wersje"
             (patrz niżej) plików są obecne, itd. Na ogół każdy programista
             ma swoją własną kopię roboczą, w której dokonuje zmian i je
             testuje, i z której wykonuje commit.</p></dd><dt><a id="vc-vocabulary-revision"/><span class="term"><em class="firstterm">wersja</em> (ang.
         <em class="firstterm">revision</em>), <em class="firstterm">zmiana</em>
         (ang. <em class="firstterm">change</em>), <em class="firstterm">zbiór
             zmian</em> (ang.
         <em class="firstterm">changeset</em>)</span></dt><dd><p>"Wersja" to na ogół konkretne wcielenie danego pliku
             lub katalogu. Na przykład plik F może być najpierw w wersji 6,
             następnie ktoś wykonuje commit zmieniający plik F, tworząc
             wersję 7 pliku F. Niektóre systemy stosują pojęcia "wersja",
             "zmiana" czy "zbiór zmian" aby opisać zbiór zmian, wysłanych w
             jednym commicie jako jedna abstrakcyjna operacja.</p><p>Niekiedy te pojęcia mają różne znaczenia w poszczególnych
             systemach kontroli wersji, ale sama idea pozostaje bez zmian:
             pozwalają one mówić precyzyjnie o pewnych punktach w czasie
             historii pliku lub zbioru plików (na przykład przed i po
             poprawce jakiegoś błędu). Na przykład: "Tak, naprawiła to w
             wersji 10" lub "Naprawiła to w wersji 10 pliku foo.c".</p><p>Gdy ktoś mówi o pliku lub grupie plików bez wspominania o
             konkretnej wersji, na ogół zakłada się, że ma na myśli jego
             (ich) najnowszą wersję dostępną w
             repozytorium.</p></dd><dt><a id="vc-vocabulary-diff"/><span class="term"><em class="firstterm">diff</em></span></dt><dd><p>Tekstowa reprezentacja zmiany. Diff wskazuje, które linie
          uległy zmianie i w jaki sposób, pokazując przy okazji kilka linii
          kontekstu przed i po. Programista, który zna dany obszar kodu może
          na ogół przeczytać diff i zrozumieć, na czym polega zmiana, a być
          może nawet wyłapać błędy.</p></dd><dt><a id="vc-vocabulary-tag"/><span class="term"><em class="firstterm">etykieta</em> (ang.
         <em class="firstterm">tag</em>)</span></dt><dd><p>Określa pewien zbiór plików w ściśle określonych
             wersjach. Etykiety sa na ogół używane do oznaczania ważnych
             momentów w życiu projektu. Na przykład etykieta jest na ogół
             tworzona dla każdego publicznego wydania, tak, aby każdy mógł
             pobrać bezpośrednio z repozytorium dokładnie te same wersje
             plików, które zostały wydane. Popularnymi nazwami etykiet są na
             przykład <code class="literal">Release_1_0</code>,
             <code class="literal">Delivery_00456</code>, itd.</p></dd><dt><a id="vc-vocabulary-branch"/><span class="term"><em class="firstterm">gałąź</em> (ang.
         <em class="firstterm">branch</em>)</span></dt><dd><p>Kopia projektu znajdująca się w repozytorium, ale
             izolowana w taki sposób, że zmiany w gałęzi nie wpływają na
             resztę projektu, i odwrotnie, do czasu gdy zmiany nie zostaną
             przez kogoś "scalone" (patrz niżej). Gałęzie bywają także
             nazywane "liniami rozwoju". Nawet gdy projekt nie posiada wielu
             gałęzi, mówi się że rozwój odbywa się na "głównej gałęzi",
             także nazywanej "<em class="firstterm">pniem</em>" (ang.
             <em class="firstterm">trunk</em>).</p><p>Gałęzie dają możliwość odizolowania od siebie różnych linii
             rozwoju. Na przykład gałąź może powstać na potrzeby
             eksperymentalnego kodu, który mógłby zdestabilizować główną
             gałąź. Albo odwrotnie, gałąź może być użyta jako miejsce, w
             którym nowe wydanie będzie stabilizowane. Podczas procesu
             wydania normalny rozwój może odbywać się w głównej gałęzi
             repozytorium, a w tym samym czasie na gałęzi utworzonej dla
             wydania nie będą akceptowane żadne zmiany oprócz tych, które
             zostały dozwolone przez zarządzających wydaniem. W ten sposób
             wydanie nowej wersji nie musi kolidować z normalnym rozwojem.
             Patrz <a class="xref" href="ch03s03.html#branches" title="Use branches to avoid bottlenecks">„Use branches to avoid bottlenecks”</a><span> dalej
                 w tym rozdziale</span> aby dowiedzieć się więcej o
             gałęziach.</p></dd><dt><a id="vc-vocabulary-merge"/><span class="term"><em class="firstterm">scalanie lub portowanie</em> (ang.
         <em class="firstterm">merge</em> lub
         <em class="firstterm">port</em>)</span></dt><dd><p>Przeniesienie zmiany z jednej gałęzi na inną. Chodzi
             zarówno o scalanie zmian z głównej gałęzi do innej gałęzi, jak
             i w drugą stronę. To najczęściej stosowane w praktyce rodzaje
             scaleń—rzadko przenosi się zmiany pomiędzy dwoma
             gałęziami, z których żadna nie jest główną. Patrz <a class="xref" href="ch03s03.html#vc-singularity" title="Singularity of information">„Singularity of information”</a> oby dowiedzieć się więcej o
             takich scalaniach.</p><p>"Scalanie" ma jeszcze drugie, podobne znaczenie: to
             zachowanie systemu kontroli wersji gdy stwierdzi, że dwóch
             użytkowników dokonało zmian w tym samym pliku, które nie
             zachodzą na siebie. Takie zmiany na ogół nie mają na siebie
             wpływu, więc u tego użytkownika, który dokona aktualizacji
             pliku (w którym sam dokonał zmian), zmiany innych zostaną
             automatycznie scalone. To bardzo częsta sytuacja, szczególnie w
             projektach, w których wiele osób pracuje nad tym samym kodem.
             Gdy dwie różne zmiany <span class="emphasis"><em>zachodzą</em></span> na siebie,
             pojawia się "konflikt" (patrz niżej).</p></dd><dt><a id="vc-vocabulary-conflict"/><span class="term"><em class="firstterm">konflikt</em> (ang.
         <em class="firstterm">conflict</em>)</span></dt><dd><p>Konflikt zachodzi, gdy dwie osoby próbują dokonać zmian
             dokładnie w tym samym miejscu kodu. Wszystkie systemy kontroli
             wersji automatycznie wykrywają konflikty i powiadamiają jednego
             z użytkowników o ich istnieniu. Reszta jest w rękach człowieka,
             musi on ręcznie <em class="firstterm">rozwiązać</em> (ang.
             <em class="firstterm">resolve</em>) konflikt i poinformować o tym
             system kontroli wersji.</p></dd><dt><a id="vc-vocabulary-lock"/><span class="term"><em class="firstterm">blokada</em> (ang.
         <em class="firstterm">lock</em>)</span></dt><dd><p>Sposób na zadeklarowanie wyłączności na zmiany w danym
             pliku lub katalogu. Na przykład: "Nie mogę zrobić commitu moich
             zmian w stronach WWW. Wygląda na to, że Alfred założył blokadę
             na czas poprawek w obrazkach tła." Nie wszystkie systemy
             kontroli wersji pozwalają na stosowanie blokad, a z tych które
             pozwalają, nie wszystkie wymagają korzystania z nich. To
             dlatego, że równoległy wspólny rozwój jest standardem, a
             blokowanie plików przed zmianami innych jest (na ogół)
             sprzeczne z tą ideą.</p><p>Mówi się, że systemy kontroli wersji, które wymagają
             stosowania blokad aby wykonać commit, pracują w modelu
             <em class="firstterm">blokada-modyfikacja-odblokowanie</em>. Te,
             które ich nie wymagają stosują model
             <em class="firstterm">kopia-modyfikacja-scalanie</em>. Doskonałe
             wyjaśnienie i porównanie obu modeli można znaleźć w <a class="ulink" href="http://svnbook.red-bean.com/svnbook-1.0/ch02s02.html">http://svnbook.red-bean.com/svnbook-1.0/ch02s02.html</a>.
             Na ogół model kopia-modyfikacja-scalanie jest lepszy dla
             rozwoju otwartego oprogramowania, i wszystkie systemy kontroli
             wersji omówione w tym rozdziale wspierają taki
             model.</p></dd></dl></div><p>

</p></div><div class="sect2" title="Wybór systemu kontroli wersji"><div class="titlepage"><div><div><h2 class="title"><a id="vc-choosing"/>Wybór systemu kontroli wersji</h2></div></div></div><p>W chwili pisania tych słów dwoma najpopularniejszymi systemami kontroli
wersji w świecie wolnego oprogramowania sią <em class="firstterm">CVS</em>
(<em class="firstterm">Concurrent Versions System</em>, <a class="ulink" href="http://www.cvshome.org/">http://www.cvshome.org/</a>) i <em class="firstterm">SVN</em>
(<em class="firstterm">Subversion</em>, <a class="ulink" href="http://subversion.tigris.org/">http://subversion.tigris.org/</a>).</p><p>CVS istnieje od bardzo dawna. Większość doświadczonych programistów jest
już przyzwyczajona do korzystania z niego. Mniej więcej spełania swoje
zadanie i jest popularny od bardzo dawna, więc wybierając CVS raczej nie
doprowadzisz do długiej dyskusji o tym, czy to dobry wybór. Jednak CVS ma
pewne wady. Nie pozwala na łatwe odróżnianie tego, że dana zmiana dotyczyła
wielu plików, nie pozwala na zmianę nazwy czy kopiowanie plików pod kontrolą
wersji (jeśli więc potrzebujesz przeorganizować strukturę kodu w trakcie
projektu, masz problem), ma słabe wsparcie dla scalania, nie obsługuje dobrze
dużych plików ani plików binarnych, a niektóre operacje bywają bardzo powolne,
gdy dotyczą wielu plików.</p><p>Żadna z tych wad nie jest dyskwalifikująca, więc CVS jest wciąż dość
popularny. Jednak w ostatnich kilku latach system kontroli wersji Subversion
zaczął zyskiwać zwolenników, szczególnie w nowszych
projektach.<sup>[<a id="idp6278448" href="#ftn.idp6278448" class="footnote">17</a>]</sup> Jeśli rozpoczynasz nowy
projekt, polecam Subversion.</p><p>Z drugiej strony jestem zaangażowany w projekt Subversion, więc moja
    obiektywność może być kwestionowana. Co więcej, w ostatnich latach
    pojawiło się wiele nowych systemów kontroli wersji na wolnych licencjach.
    <a class="xref" href="apa.html" title="Dodatek A. Wolne Systemy Kontroli Wersji (VCS)">Dodatek A, <em>Wolne Systemy Kontroli Wersji (VCS)</em></a> zawiera listę wszystkich, które znam,
    posortowanych według (przybliżonej) popularności. Uświadamia ona, że wybór
    systemu kontroli wersji może stać się projektem badawczym na całe życie.
    Być może dylematów pozbawi Cię dostawca hostingu, jeśli jednak musisz
    wybierać, porozmawiaj z innymi programistami, zapytaj znajomych o ich
    doświadczenia, a następnie wybierz jeden system i przy nim pozostań. Każdy
    stabilny i gotowy do zastnowań produkcyjnych system kontroli wersji
    powinien wystarczyć, nie musisz martwić się za bardzo skutkami swojej
    decyzji. Jeśli jednak nie możesz się zdecydować, skorzystaj z Subversion.
    Jest dość łatwy w nauce, i najprawdopodobniej pozostanie standardem przez
    przynajmniej kilka late.</p></div><div class="sect2" title="Korzystanie z systemu kontroli wersji"><div class="titlepage"><div><div><h2 class="title"><a id="vc-using"/>Korzystanie z systemu kontroli wersji</h2></div></div></div><p>Rady w tym rozdziale nie dotyczą jakiegoś konkretnego systemu kontroli
    wersji, ich zastosowanie powinno być łatwe w każdym z nich. Sprawdź
    dokumentację Twojego systemu kontroli wersji aby dowiedzieć się
    wiecej.</p><div class="sect3" title="Wersjonuj wszystko"><div class="titlepage"><div><div><h3 class="title"><a id="version-everything"/>Wersjonuj wszystko</h3></div></div></div><p>Kontrolę wersji stosuj nie tylko dla kodu źródłowego projeku, ale także
    strony internetowej, dokumentacji, FAQ, dokumentów projektowych i
    wszystkiego innego, co ludzie mogliby edytować. Przechowuj je zaraz obok
    kodu, w tym samym repozytorium. Każdą informację, którą warto zapisać,
    warto też wersjonować—a więc każdą informację, która może ulec
    zmienie. Rzeczy które nie ulegają zmianie powinny być archiwizowane, nie
    wersjonowane. Na przykład email po wysłaniu nie może już zmienić treści, a
    więc kontrola wersji w tym przypadku nie miałaby sensu (do czasu, gdy nie
    stanie się częścią jakiegoś większego, ewolującego dokumentu).</p><p>Wersjonowanie wszystkiego razem, w jednym miejscu, jest tak ważne, gdyż
    wtedy ludzi muszą nauczyć się tylko jednego mechanizmu nadsyłania zmian.
    Często uczestnik projektu zaczyna od edycji strony internetowej czy
    dokumentacji, a następnie stopniowo przechodzi do trudniejszych zadań. Gdy
    projekt korzysta z tego samego systemu dla wszystkich zmian, ludzi muszą
    nauczyć się korzystać z niego jedynie raz. Wersjonowanie wszystkiego razem
    oznacza też, że commit nowego kodu może zawierać też aktualizację
    dokumentacji, utworzenie gałęzi kodu tworzy także gałąź dokumentacji, i
    tak dalej.</p><p>W przechowuj w repozytorium <em class="firstterm">plików generowanych</em>.
    Nie są one edytowalnymi danymi, gdyż są generowane automatycznie na
    podstawie innych plików. Na przykład niektóre systemy budowania tworzą
    plik <code class="filename">configure</code> w oparciu o szablon
    <code class="filename">configure.in</code>. Aby dokonać zmian w pliku
    <code class="filename">configure</code> należy wyedytować
    <code class="filename">configure.in</code> i wygenerować plik wynikowy, a więc
    jedynie szablon jest "plikiem edytowalnym". Wersjonuj jedynie
    szablony—jeśli będziesz wersjonować także pliki wynikowe, ludzi będą
    zapominać o tym, aby je ponownie wygenerować po dokonaniu zmian w
    szablonie, a wynikające z tego niespójności będą prowadzić do sporego
    zamieszania.<sup>[<a id="idp6287392" href="#ftn.idp6287392" class="footnote">18</a>]</sup></p><p>Od zasady mówiącej, że wszystkie edytowalne dane powinny być przechowywane w
    systemie kontroli wersji, jest niestety jeden wyjątek: system śledzenia
    błędów. Bazy błędów zawierają wiele edytowalnych danych, ale z powodów
    technicznych nie przechowują ich w głównym systemie kontroli wersji.
    Niektóre z nich mają własne prymitywne możliwości wersjonowania, są one
    jednak zupełnie niezależne od głównego repozytorium projektu.</p></div><div class="sect3" title="Możliwość przeglądania"><div class="titlepage"><div><div><h3 class="title"><a id="vc-browsing"/>Możliwość przeglądania</h3></div></div></div><p>Repozytorium projektu powinno dać się przeglądać przy użyciu
    przeglądarki internetowej. Nie chodzi tu tylko o możliwość dostępu do
    najnowszych wersji plików, ale także cofanie się w czasie i podgląd
    starych wersji, porównywanie różnic pomiędzy wersjami, czytania komentarzy
    do zmian, i tak dalej.</p><p>Możliwość przeglądania jest istotna, ponieważ daje możliwość łatwego
    dostępu do danych projektu. Gdyby repozytorium nie było dostępne za pomocą
    przeglądarki, wtedy każdy kto chciałby sprawdzić zawartość jakiegoś pliku
    (na przykład aby sprawdzić, czy pewna poprawka została dołączona do kodu)
    musiałby najpierw zainstalować u siebie klienta systemu kontroli wersji,
    co mogłoby zmienić kilkuminutowe zapytanie w pół godzinne zadanie.</p><p>Możliwość przeglądania zakłada też istnienie standardowych adresów do
    przeglądania wybranych wersji plików, włączając w to tę najnowszą. To może
    być bardzo przydatne w dyskusjach technicznych lub w odsyłaczach do
    dokumentacji. Na przykład zamiast mówić "Aby znaleźć porady dotyczące
    debugowania serwera sprawdź plik www/hacking.html w swojej kopii roboczej"
    można powiedzieć "Aby znaleźć porady dotyczące debugowania serwera sprawdź
    <span class="emphasis"><em>http://subversion.apache.org/docs/community-guide/</em></span>",
    podając adres wskazujący na najbardziej aktualną wersję pliku
    <code class="filename">hacking.html</code>. Adres URL jest lepszy, ponieważ jest
    jednoznaczny i niezależny od tego, na ile aktualną kopię roboczą posiada
    adresat.</p><p>Niektóre systemy kontroli wersji posiadają wbudowane mechanizmy do
    przeglądania repozytorium, inne polegają na zewnętrznych narzędziach.
    Takimi narzędziami są <em class="firstterm">ViewCVS</em> (<a class="ulink" href="http://viewcvs.sourceforge.net/">http://viewcvs.sourceforge.net/</a>),
    <em class="firstterm">CVSWeb</em> (<a class="ulink" href="http://www.freebsd.org/projects/cvsweb.html">http://www.freebsd.org/projects/cvsweb.html</a>), i
    <em class="firstterm">WebSVN</em> (<a class="ulink" href="http://websvn.tigris.org/">http://websvn.tigris.org/</a>).
    Pierwszy z nich współpracuje zarówno z CVS jak i Subversion, drugi jedynie
    z CVS, a trzeci tylko i wyłącznie z Subversion.</p></div><div class="sect3" title="Powiadomienia o commitach"><div class="titlepage"><div><div><h3 class="title"><a id="commit-emails"/>Powiadomienia o commitach</h3></div></div></div><p>Każdy commit do repozytorim powinien powodować wysłanie emaila
    zawierającego informacje o autorze zmian, czasie ich wykonania,
    zmodyfikowanych plikach i różnicach w stosunku do wersji pierwotnej. Ten
    email powinien zostać wysłany na specjalną listę dyskusyjną, odrębną od
    tej, na której dyskutują ludzie. Programiści (i inne zainteresowane osoby)
    powinni być zachęcani do subskrybowania tej listy, gdyż jest to
    najefektywniejszy sposób na to, aby śledzić zmiany w projekcie na poziomie
    kodu. Oprócz oczywistych zalet takiego przeglądu kodu (patrz <a class="xref" href="ch02s03.html#code-review" title="Practice Conspicuous Code Review">„Practice Conspicuous Code Review”</a>), takie powiadomienia wzmacniają społeczność,
    gdyż tworzą wspólne forum na którym ludzie mogą reagować na zdarzenia
    (commity) widoczne dla wszystkich innych.</p><p>Szczegóły konfiguracji powiadomień są zależne od konkretnego systemu
    kontroli wersji, ale na ogół istnieje gotowy skrypt, który można w tym
    celu wykorzystać. Jeśli masz problemy z jego odnalezieniem, spróbuj
    poszukać w dokumentacji pod hasłem <em class="firstterm">hooks</em>, a w
    szczególności <em class="firstterm">post-commit hook</em> (w terminologii CVS
    <em class="firstterm">loginfo hook</em>). Nie ma przyjętego polskiego
    odpowiednika, więc na potrzeby tego rozdziału użyjemy bezpośredniego
    tłumaczenia "hak". Haki post-commit pozwalają na automatyczne wykonywanie
    pewnych zadań w odpowiedzi na commi. Hak zostaje wykonany dla każdego
    commita, otrzymując wszystkie konieczne informacje o nim—których
    może użyć na przykład do wysłania emaila.</p><p>Czasem warto zmodyfikować domyślne zachowanie gotowego skryptu
    wysyłającego powiadomienia:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Some commit mailers don't include the actual diffs in the
  email, but instead provide a URL to view the change on the web using
  the repository browsing system.  While it's good to provide the URL,
  so the change can be referred to later, it is also
  <span class="emphasis"><em>very</em></span> important that the commit email include
  the diffs themselves.  Reading email is already part of people's
  routine, so if the content of the change is visible right there in
  the commit email, developers will review the commit on the spot,
  without leaving their mail reader.  If they have to click on a URL to
  review the change, most won't do it, because that requires a new
  action instead of a continuation of what they were already doing.
  Furthermore, if the reviewer wants to ask something about the
  change, it's vastly easier to hit reply-with-text and simply
  annotate the quoted diff than it is to visit a web page and
  laboriously cut-and-paste parts of the diff from web browser to
  email client.</p><p>(Of course, if the diff is huge, such as when a large body of
  new code has been added to the repository, then it makes sense to
  omit the diff and offer only the URL.  Most commit mailers can do
  this kind of limiting automatically.  If yours can't, then it's
  still better to include diffs, and live with the occasional huge
  email, than to leave the diffs off entirely.  Convenient reviewing
  and commenting is a cornerstone of cooperative development, much
  too important to do without.)</p></li><li class="listitem"><p>The commit emails should set their Reply-to header
  to the regular development list, not the commit email list.  That
  is, when someone reviews a commit and writes a response, their
  response should be automatically directed toward the human
  development list, where technical issues are normally discussed.
  There are a few reasons for this.  First, you want to keep all
  technical discussion on one list, because that's where people expect
  it to happen, and because that way there's only one archive to
  search.  Second, there might be interested parties not subscribed to
  the commit email list.  Third, the commit email list advertises
  itself as a service for watching commits, not for watching commits
  <span class="emphasis"><em>and</em></span> occasional technical discussions.  Those who
  subscribed to the commit email list did not sign up for anything but
  commit emails; sending them other material via that list would
  violate an implicit contract.  Fourth, people often write programs
  that read the commit email list and process the results (for
  display on a web page, for example).  Those programs are prepared to
  handle consistently-formatted commit emails, but not inconsistent
  human-written mails.</p><p>Note that this advice to set Reply-to does not contradict the
  recommendations in
  <a class="xref" href="ch03s02.html#reply-to" title="Wielka debata o nagłówek Reply-to">„Wielka debata o nagłówek Reply-to”</a><span> earlier in
  this chapter</span>.  It's
  always okay for the <span class="emphasis"><em>sender</em></span> of a message to set
  Reply-to.  In this case, the sender is the version control system
  itself, and it sets Reply-to in order to indicate that the
  appropriate place for replies is the development mailing list, not
  the commit list.</p></li></ol></div><div class="sidebar" title="CIA: Another Change Publication Mechanism"><a id="cia"/><div class="titlepage"><div><div><p class="title"><strong>CIA: Another Change Publication Mechanism</strong></p></div></div></div><p>Commit emails are not the only way to propagate change news.
Recently, another mechanism called CIA (<a class="ulink" href="http://cia.navi.cx/">http://cia.navi.cx/</a>) has been developed.  CIA is a real-time
commit statistics aggregator and distributor.  The most popular use of
CIA is to send commit notifications to IRC channels, so that people
logged into those channels see the commits happening in real time.
Though of somewhat less technical utility than commit emails, since
observers might or might not be around when a commit notice pops up in
IRC, this technique is of immense <span class="emphasis"><em>social</em></span> utility.
People get the sense of being part of something alive and active, and
feel that they can see progress being made right before their
eyes.</p><p>The way it works is that you invoke the CIA notifier program
from your post-commit hook.  The notifier formats the commit
information into an XML message, and sends to a central server
(typically <code class="literal">cia.navi.cx</code>).  That server then
distributes the commit information to other forums.</p><p>CIA can also be configured to send out <a class="ulink" href="http://www.xml.com/pub/a/2002/12/18/dive-into-xml.html">RSS</a>
feeds.  See the documentation at <a class="ulink" href="http://cia.navi.cx/">http://cia.navi.cx/</a>
for details.</p><p>To see an example of CIA in action, point your IRC
client at <code class="literal">irc.freenode.net</code>, channel
<code class="literal">#commits</code>.</p></div></div><div class="sect3" title="Use branches to avoid bottlenecks"><div class="titlepage"><div><div><h3 class="title"><a id="branches"/>Use branches to avoid bottlenecks</h3></div></div></div><p>Non-expert version control users are sometimes a bit afraid of
branching and merging.  This is probably a side effect of CVS's
popularity: CVS's interface for branching and merging is somewhat
counterintuitive, so many people have learned to avoid those
operations entirely.</p><p>If you are among those people, resolve right now to conquer any
fears you may have and take the time to learn how to do branching and
merging.  They are not difficult operations, once you get used to
them, and they become increasingly important as a project acquires
more developers.</p><p>Branches are valuable because they turn a scarce
resource—working room in the project's code—into an
abundant one.  Normally, all developers work together in the same
sandbox, constructing the same castle.  When someone wants to add a
new drawbridge, but can't convince everyone else that it would be an
improvement, branching makes it possible for her to go to an isolated
corner and try it out.  If the effort succeeds, she can invite the
other developers to examine the result.  If everyone agrees that the
result is good, they can tell the version control system to move
("merge") the drawbridge from the branch castle over to the main
castle.</p><p>It's easy to see how this ability helps collaborative
development.  People need the freedom to try new things without
feeling like they're interfering with others' work.  Equally
importantly, there are times when code needs to be isolated from the
usual development churn, in order to get a bug fixed or a release
stabilized (see <a class="xref" href="ch07s03.html" title="Stabilizing a Release">„Stabilizing a Release”</a> and
<a class="xref" href="ch07s06.html" title="Maintaining Multiple Release Lines">„Maintaining Multiple Release Lines”</a><span> in
<a class="xref" href="ch07.html" title="Rozdział 7. Packaging, Releasing, and Daily Development">Rozdział 7, <em>Packaging, Releasing, and Daily Development</em></a></span>) without worrying
about tracking a moving target.</p><p>Use branches liberally, and encourage others to use them.  But
also make sure that a given branch is only active for exactly as long
as needed.  Every active branch is a slight drain on the community's
attention.  Even those who are not working in a branch still maintain
a peripheral awareness of what's going on in it.  Such awareness is
desirable, of course, and commit emails should be sent out for branch
commits just as for any other commit.  But branches should not become
a mechanism for dividing the development community.  With rare
exceptions, the eventual goal of most branches should be to merge
their changes back into the main line and disappear.</p></div><div class="sect3" title="Singularity of information"><div class="titlepage"><div><div><h3 class="title"><a id="vc-singularity"/>Singularity of information</h3></div></div></div><p>Merging has an important corollary: never commit the same change
twice.  That is, a given change should enter the version control
system exactly once.  The revision (or set of revisions) in which the
change entered is its unique identifier from then on.  If it needs to
be applied to branches other than the one on which it entered, then it
should be merged from its original entry point to those other
destinations—as opposed to committing a textually identical
change, which would have the same effect in the code, but would make
accurate bookkeeping and release management impossible.</p><p>The practical effects of this advice differ from one version
control system to another.  In some systems, merges are special
events, fundamentally distinct from commits, and carry their own
metadata with them.  In others, the results of merges are committed
the same way other changes are committed, so the primary means of
distinguishing a "merge commit" from a "new change commit" is in the
log message.  In a merge's log message, don't repeat the log message
of the original change.  Instead, just indicate that this is a merge,
and give the identifying revision of the original change, with at most
a one-sentence summary of its effect.  If someone wants to see the
full log message, she should consult the original revision.</p><p>The reason it's important to avoid repeating the log message is
that log messages are sometimes edited after they've been committed.
If a change's log message were repeated at each merge destination,
then even if someone edited the original message, she'd still leave
all the repeats uncorrected—which would only cause confusion
down the road.</p><p>The same principle applies to reverting a change.  If a change
is withdrawn from the code, then the log message for the reversion
should merely state that some specific revision(s) is being reverted,
<span class="emphasis"><em>not</em></span> describe the actual code change that results
from the reversion, since the semantics of the change can be derived
by reading the original log message and change.  Of course, the
reversion's log message should also state the reason why the change is
being reverted, but it should not duplicate anything from the original
change's log message.  If possible, go back and edit the original
change's log message to point out that it was reverted.</p><p>All of the above implies that you should use a consistent syntax
for referring to revisions.  This is helpful not only in log messages,
but in emails, the bug tracker, and elsewhere.  If you're using
CVS, I suggest "<code class="literal">path/to/file/in/project/tree:REV</code>",
where REV is a CVS revision number such as "1.76".  If you're using
Subversion, the standard syntax for revision 1729 is "r1729" (file
paths are not needed because Subversion uses global revision numbers).
In other systems, there is usually a standard syntax for expressing
the changeset name.  Whatever the appropriate syntax is for your
system, encourage people to use it when referring to changes.
Consistent expression of change names makes project bookkeeping much
easier (as we will see in <a class="xref" href="ch06.html" title="Rozdział 6. Communications">Rozdział 6, <em>Communications</em></a> and
<a class="xref" href="ch07.html" title="Rozdział 7. Packaging, Releasing, and Daily Development">Rozdział 7, <em>Packaging, Releasing, and Daily Development</em></a>), and since a lot of the
bookkeeping will be done by volunteers, it needs to be as easy as
possible.</p><p>See also
<a class="xref" href="ch07s07.html" title="Releases and Daily Development">„Releases and Daily Development”</a><span> in
<a class="xref" href="ch07.html" title="Rozdział 7. Packaging, Releasing, and Daily Development">Rozdział 7, <em>Packaging, Releasing, and Daily Development</em></a></span>.</p></div><div class="sect3" title="Authorization"><div class="titlepage"><div><div><h3 class="title"><a id="vc-authz"/>Authorization</h3></div></div></div><p>Most version control systems offer a feature whereby certain
people can be allowed or disallowed from committing in specific
sub-areas of the repository.  Following the principle that when handed
a hammer, people start looking around for nails, many projects use
this feature with abandon, carefully granting people access to just
those areas where they have been approved to commit, and making sure
they can't commit anywhere else.  (See
<a class="xref" href="ch08s04.html" title="Prawo zapisu">„Prawo zapisu”</a><span> in
<a class="xref" href="ch08.html" title="Rozdział 8. Zarządzanie ochotnikami">Rozdział 8, <em>Zarządzanie ochotnikami</em></a></span> for how projects
decide who can commit where.)</p><p>There is probably little harm done by exercising such tight
control, but a more relaxed policy is fine too.  Some projects simply
use an honor system: when a person is granted commit access, even for
a sub-area of the repository, what they actually receive is a password
that allows them to commit anywhere in the project.  They're just
asked to keep their commits in their area.  Remember that there is no
real risk here: in an active project, all commits are reviewed anyway.
If someone commits where they're not supposed to, others will
notice it and say something.  If a change needs to be undone, that's
simple enough—everything's under version control anyway, so
just revert.</p><p>There are several advantages to the relaxed approach.  First, as
developers expand into other areas (which they usually will if they
stay with the project), there is no administrative overhead to
granting them wider privileges.  Once the decision is made, the person
can just start committing in the new area right away.</p><p>Second, expansion can be done in a more fine-grained manner.
Generally, a committer in area X who wants to expand to area Y will
start posting patches against Y and asking for review.  If someone who
already has commit access to area Y sees such a patch and approves of
it, they can just tell the submitter to commit the change directly
(mentioning the reviewer/approver's name in the log message, of
course).  That way, the commit will come from the person who actually
wrote the change, which is preferable from both an information
management standpoint and from a crediting standpoint.</p><p>Last, and perhaps most important, using the honor system
encourages an atmosphere of trust and mutual respect.  Giving someone
commit access to a subdomain is a statement about their technical
preparedness—it says: "We see you have expertise to make commits
in a certain domain, so go for it."  But imposing strict authorization
controls says: "Not only are we asserting a limit on your expertise,
we're also a bit suspicious about
your <span class="emphasis"><em>intentions</em></span>."  That's not the sort of
statement you want to make if you can avoid it.  Bringing someone into
the project as a committer is an opportunity to initiate them into a
circle of mutual trust.  A good way to do that is to give them more
power than they're supposed to use, then inform them that it's up to
them to stay within the stated limits.</p><p>The Subversion project has operated on the honor system way for
more than four years, with 33 full and 43 partial committers as of
this writing.  The only distinction the system actually enforces is
between committers and non-committers; further subdivisions are
maintained solely by humans.  Yet we've never had a problem with
someone deliberately committing outside their domain.  Once or twice
there's been an innocent misunderstanding about the extent of
someone's commit privileges, but it's always been resolved quickly and
amiably.</p><p>Obviously, in situations where self-policing is impractical, you
must rely on hard authorization controls.  But such situations are
rare.  Even when there are millions of lines of code and hundreds or
thousands of developers, a commit to any given code module should
still be reviewed by those who work on that module, and they can
recognize if someone committed there who wasn't supposed to.  If
regular commit review <span class="emphasis"><em>isn't</em></span> happening, then the
project has bigger problems to deal with than the authorization system
anyway.</p><p>In summary, don't spend too much time fiddling with the version
control authorization system, unless you have a specific reason to.  It
usually won't bring much tangible benefit, and there are advantages to
relying on human controls instead.</p><p>None of this should be taken to mean that the restrictions
themselves are unimportant, of course.  It would be bad for a project
to encourage people to commit in areas where they're not qualified.
Furthermore, in many projects, full (unrestricted) commit access has a
special status: it implies voting rights on project-wide questions.
This political aspect of commit access is discussed more in <a class="xref" href="ch04s02.html#electorate" title="Who Votes?">„Who Votes?”</a><span> in
<a class="xref" href="ch04.html" title="Rozdział 4. Social and Political Infrastructure">Rozdział 4, <em>Social and Political Infrastructure</em></a></span>.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"/><div class="footnote"/><div class="footnote"/><div class="footnote"><p><sup>[<a id="ftn.idp6278448" href="#idp6278448" class="para">17</a>] </sup>Patrz <a class="ulink" href="http://cia.vc/stats/vcs">http://cia.vc/stats/vcs</a> i
<a class="ulink" href="http://subversion.tigris.org/svn-dav-securityspace-survey.html">http://subversion.tigris.org/svn-dav-securityspace-survey.html</a>
aby zobaczyć dowody tego trendu.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp6287392" href="#idp6287392" class="para">18</a>] </sup>Aby poznać inną opinię na temat wersjonowania
            plików <code class="filename">configure</code>, przeczytaj wpis na blogu
            Alexey'a Makhotkina zatytułowany "<em class="citetitle">configure.in and
                version control</em>", dostępny pod adresem <a class="ulink" href="http://versioncontrolblog.com/2007/01/08/configurein-and-version-control/">http://versioncontrolblog.com/2007/01/08/configurein-and-version-control/</a>.</p></div></div></div></body></html>
