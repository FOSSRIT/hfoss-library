<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 4. Social and Political Infrastructure</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="chapter" title="Chapter 4. Social and Political Infrastructure"><div class="titlepage"><div><div><h1 class="title"><a id="social-infrastructure"/>Chapter 4. Social and Political Infrastructure</h1></div></div></div><div class="simplesect"><div class="titlepage"/><p>The first questions people usually ask about free software are
"How does it work?  What keeps a project running?  Who makes the
decisions?"  I'm always dissatisfied with bland responses about
meritocracy, the spirit of cooperation, code speaking for itself, etc.
The fact is, the question is not easy to answer.  Meritocracy,
cooperation, and running code are all part of it, but they do little
to explain how projects actually run on a day-to-day basis, and say
nothing about how conflicts are resolved.</p><p>This chapter tries to show the structural underpinnings
successful projects have in common.  I mean "successful" not just in
terms of technical quality, but in terms of operational health and
survivability.  Operational health is the project's ongoing ability to
incorporate new code contributions and new developers, and to be
responsive to incoming bug reports.  Survivability is the project's
ability to exist independently of any individual participant or
sponsor — think of it as the likelihood that the project would
continue even if all of its founding members were to move on to other
things<sup>[<a id="idm1792" href="#ftn.idm1792" class="footnote">43</a>]</sup>.
Technical success is not hard to achieve, but without a
robust developer base and social foundation, a project may be unable
to handle the growth that initial success brings, or the departure of
charismatic individuals.</p><p>There are various ways to achieve this kind of success.  Some
involve a formal governance structure, by which debates are resolved,
new developers are invited in (and sometimes out), new features
planned, and so on.  Others use less formal structure, but more
self-restraint, to produce an atmosphere of fairness that
people can rely on as a <span class="foreignphrase"><em class="foreignphrase">de facto</em></span> form
of governance.  Both ways lead to the same result: a sense of
institutional permanence, supported by habits and procedures that are
well understood by everyone who participates.  These features are even
more important in self-organizing systems than in centrally-controlled
ones, because in self-organizing systems, everyone is conscious that a
few bad apples can spoil the whole barrel, at least for a while.</p></div><div class="sect1" title="Forkability"><div class="titlepage"><div><div><h1 class="title"><a id="forkability"/>Forkability</h1></div></div></div><p>The indispensable ingredient that binds developers together on a
free software project, and makes them willing to compromise when
necessary, is the code's <em class="firstterm">forkability</em>: the
ability of anyone to take a copy of the source code and use it to
start a competing project, known as a
<em class="firstterm">fork</em>.<sup>[<a id="idm1803" href="#ftn.idm1803" class="footnote">44</a>]</sup></p><p>The paradoxical thing is that the <span class="emphasis"><em>possibility</em></span> of
forks is usually a much greater force in free software projects than
actual forks, which are very rare.  Because a fork is usually bad for
everyone (for reasons examined in detail in
<a class="xref" href="ch08s06.html" title="Forks">the section called “Forks”</a><span> in
<a class="xref" href="ch08.html" title="Chapter 8. Managing Participants">Chapter 8, <em>Managing Participants</em></a></span>), the more serious
the threat of a fork becomes, the more willing people are to
compromise to avoid it.</p><p>Forks, or rather the potential for forks, are the reason there
are no true dictators in free software projects.  This may seem like a
surprising claim, considering how common it is to hear someone called
the "dictator" (sometimes softened to "benevolent dictator") in a
given open source project.  But this kind of dictatorship is special,
quite different from the conventional understanding of the word.
Imagine a king whose subjects could copy his entire kingdom at any
time and move to the copy to rule as they see fit.  Would not such a
king govern very differently from one whose subjects were bound to
stay under his rule no matter what he did?</p><p>This is why even projects that are not formally organized as
democracies are, in practice, democracies when it comes to important
decisions.  Replicability implies forkability; forkability implies
consensus.  It may well be that everyone is willing to defer to one
leader (the most famous example being Linus Torvalds in Linux kernel
development), but this is because they <span class="emphasis"><em>choose</em></span> to
do so, in an entirely non-cynical and non-sinister way.  The dictator
has no magical hold over the project.  A key property of all open
source licenses is that they do not give one party more power than any
other in deciding how the code can be changed or used.  If the dictator
were to suddenly start making bad decisions, there would be
restlessness, followed eventually by revolt and a fork.  Except, of
course, that things rarely get that far, because the dictator compromises
first.</p><p>But just because forkability puts an upper limit on how much
power anyone can exert in a project doesn't mean there aren't
important differences in how projects are governed.  You don't want
every decision to come down to the last-resort question of who might
consider a fork.  That would get tiresome very quickly, and sap
energy away from real work.  The next two sections examine different
ways to organize projects such that most decisions go smoothly.  These
two examples are somewhat idealized extremes; many projects fall
somewhere along a continuum between them.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.idm1792" href="#idm1792" class="para">43</a>] </sup>This is also known as the "<em class="firstterm">Bus
Factor</em>", that is, how many participants would have to get hit by a bus
(figuratively speaking) for the project to be unable to continue.  See
<a class="ulink" href="https://en.wikipedia.org/wiki/Bus_factor">https://en.wikipedia.org/wiki/Bus_factor</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.idm1803" href="#idm1803" class="para">44</a>] </sup>Meaning a "social fork",
not the unrelated "short fork" that is often a normal part of the
development cycle.  See <a class="xref" href="ch08s06.html#social-forks-vs-short-forks" title="&quot;Social Forks&quot; versus &quot;Short Forks&quot;">"Social Forks" versus "Short Forks"</a><span> in
<a class="xref" href="ch08.html" title="Chapter 8. Managing Participants">Chapter 8, <em>Managing Participants</em></a></span> for more on this crucial
distinction.</p></div></div></div></body></html>