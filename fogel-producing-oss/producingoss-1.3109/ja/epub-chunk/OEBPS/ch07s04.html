<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>パッケージング</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="sect1" title="パッケージング"><div class="titlepage"><div><div><h1 class="title"><a id="packaging"/>パッケージング</h1></div></div></div><p>
    フリーソフトウェアを配布する標準的なやり方は、ソースコードを配布することです。
    これはソフトウェアがソースコードをそのまま実行できる(i.e. Perl, Python, PHP などのように、
    インタプリタによって解釈できるもの)か、
    はじめに(C, C++, Javaなどによって）コンパイルする必要があるかどうかに関わらず当てはまります。
    コンパイルする必要があるソフトウェアの場合、
    ほとんどのユーザーが多分自分でソースをコンパイルせず、
    あらかじめビルドされたバイナリパッケージをインストールするでしょう。
    (<span>この章の後半にある</span> <a class="xref" href="ch07s04.html#binary-packages" title="バイナリパッケージ">「バイナリパッケージ」</a> を参照してください)
    しかしながら、バイナリパッケージはオリジナルのソースコードを元にして作られています。
    ソースパッケージで重要なのは、曖昧でない形でリリースを定義していることです。
    プロジェクトが "Scanley 2.5.0" を配布する場合、それが特に意味するところは "コンパイルして（必要であれば）インストールすると、Scanley 2.5.0 を生成するソースファイルのツリーである" ということです。
</p><p>
    どういう形でソースファイルをリリースすべきかについては、かなり厳格な基準があります。
    基準から外れた部分も時折見つかるでしょうが、それはルールではなく例外です。
    やむを得ない理由がなければ、あなたのプロジェクトでもこの基準に従うべきです。
</p><div class="sect2" title="パッケージのフォーマット"><div class="titlepage"><div><div><h2 class="title"><a id="packaging-format"/>パッケージのフォーマット</h2></div></div></div><p>
    ソースコードはディレクトリツリーを保存してくれる標準的なフォーマットでリリースすべきです。
    Unix または Unixライクなオペレーティングシステムでは、
    <span class="command"><strong>compress</strong></span> コマンドや、<span class="command"><strong>gzip</strong></span>、
    <span class="command"><strong>bzip</strong></span> または <span class="command"><strong>bzip2</strong></span> コマンドを使って圧縮した TAR フォーマットを使うという決まりがあります。Microsoft Windows では、
    ディレクトリツリーを保存した状態で配布する標準的なやり方として <em class="firstterm">zip</em> フォーマットを使う方法があります。これはたまたま圧縮もしてくれるので、
    アーカイブを作った後に圧縮を行う必要がありません。
</p><div class="sidebar" title="TAR ファイル"><a id="packaging-tar"/><div class="titlepage"><div><div><p class="title"><strong>TAR ファイル</strong></p></div></div></div><p>
       <em class="firstterm">TAR</em> とは、"Tape ARchive" を略したものです。
       なぜなら、tar フォーマットはディレクトリツリーを磁気テープに保存するのに理想的な直列のデータストリームとして表現するからです。
       また、この性質ゆえにディレクトリツリーを単一のファイルとして配布することが標準となっています。
       圧縮された tar ファイル(または<em class="firstterm">tarボール</em>)を提供するのは非常に簡単です。
       システムによっては、<span class="command"><strong>tar</strong></span>コマンド自体が圧縮済みのtarボールを生成するものもありますし、
       圧縮するのにtarコマンドとは別のコマンドを使うシステムもあります。
   </p></div></div><div class="sect2" title="パッケージ名とレイアウト"><div class="titlepage"><div><div><h2 class="title"><a id="packaging-name-and-layout"/>パッケージ名とレイアウト</h2></div></div></div><p>
    パッケージの名前は、ソフトウェアの名前とリリース番号の後で、
    アーカイブのやり方に合った適切なフォーマットの拡張子を最後につけるようにしましょう。
    たとえば、Scanley 2.5.0 を Unix向けにパッケージングし、
    GNU Zip(gzip) フォーマットで圧縮したときの名前は次のようになるでしょう。
</p><div class="informalexample"><div class="literallayout"><p>scanley-2.5.0.tar.gz</p></div></div><p>
    また、Windows 向けに zip フォーマットで圧縮した場合の名前は次のようになるでしょう。
</p><div class="informalexample"><div class="literallayout"><p>scanley-2.5.0.zip</p></div></div><p>
    どちらのアーカイブを展開しても、
    カレントディレクトリに scanley-2.5.0 という名前の単一のディレクトリツリーが生成されるはずです。
    このディレクトリには、ソースコードを(必要なら)コンパイルし、
    インストールできる状態でソースコードを配置すべきでしょう。
    ディレクトリツリーの最上部には、このソフトウェアが何をするもので、
    今回のリリース内容がどういうものか、
    そしてプロジェクトのWebサイトやその他面白いファイルなどのリソースについて説明した <code class="filename">README</code> ファイルをプレーンテキストで配置します。
    他の面白いファイルとしては、<code class="filename">README</code> ファイルの兄弟分にあたり、
    サポートする全てのオペレーティングシステム上でソフトウェアをビルドし、
    インストールする方法を説明した <code class="filename">INSTALL</code> ファイルがあげられます。
    <span><a class="xref" href="ch02.html" title="第2章 さあ始めましょう">2章<em>さあ始めましょう</em></a> の</span> <a class="xref" href="ch02s02.html#license-quickstart-applying" title="ライセンスを適用する方法">「ライセンスを適用する方法」</a> でも説明していますが、
    ソフトウェアの配付条件を示した <code class="filename">COPYING</code> や <code class="filename">LICENSE</code>ファイルもツリーの最上部に配置します。
</p><p>
    今回のリリースで新しくなったことを説明する <code class="filename">CHANGES</code> (<code class="filename">NEWS</code> と呼ばれることもあります) ファイルもツリーの最上部に配置します。
    この <code class="filename">CHANGES</code> ファイルは、
    これまで行われたリリース全ての変更点を集めたもので、
    今回のリリースの変更点の一覧が一番最初になるように、
    リリースされた順番とは逆順に記されています。
    この変更点一覧を完成させるのは、
    リリースブランチをリリースできる状態にする作業の最後に行うのが普通です。
    開発している間に少しずつ変更点を書き足していくプロジェクトもあれば、
    バージョン管理システムのログを組み合わせることで情報を集め、
    最後にひとりの人間がまとめるまで作業を保留するのを好むプロジェクトもあります。
    変更点の一覧は、次のようになるでしょう。
</p><pre class="screen">
Version 2.5.0
(2004年12月20日に /branches/2.5.x からリリース)
http://svn.scanley.org/repos/svn/tags/2.5.0/

 新機能、改良点:
    * 正規表現による問い合わせを追加 (問題 #53)
    * UTF-8 と UTF-16 で書かれたドキュメントのサポートを追加
    * ドキュメントが ポーランド語、ロシア語、マダガスカル語に翻訳された。
    * ...

 バグ修正:
    * 再インデックス時のバグを修正 (問題 #945)
    * 問い合わせに関するバグをいくつか修正 (問題 #815, #1007, #1008)
    * ...
</pre><p>
    変更点の一覧は、必要であればどれだけ長くても構いませんが、
    小さなバグ修正や機能追加を全て含めてしまうことで、内容が退屈にならないようにしましょう。
    このファイルの目的は、新しいリリースにアップグレードすることで得られるものの概要をユーザーに示すだけです。
    実際、変更点の一覧はリリースアナウンスの電子メールに書くことが普通なので、
    それを見る人のことを考えて書くようにしましょう。
</p><div class="sidebar" title="CHANGES ファイルと ChangeLog ファイル"><a id="changelog"/><div class="titlepage"><div><div><p class="title"><strong>CHANGES ファイルと ChangeLog ファイル</strong></p></div></div></div><p>
       伝統的に <em class="firstterm">ChangeLog</em> ファイルは、
       プロジェクトでこれまで行われたあらゆる変更を一覧にします。
       — つまり、バージョン管理システムにコミットされた全てのリビジョンです。
       ChangeLog ファイルには様々なフォーマットがあります。
       どんなフォーマットでも同じ情報が含まれているので、
       フォーマットの詳細はここでは重要ではありません。
       その情報とは、変更日、変更した人、変更に関する簡単な要約(または単にその変更のログメッセージ）です。
   </p><p>
       <code class="filename">CHANGES</code> ファイルは違います。
       このファイルは変更点を一覧にするだけでなく、
       ある人達が見て重要だと思われるものも一覧に加えます。
       そして正確な変更日や変更した人のようなメタデータはよく省略されます。
       混乱を避けるため、CHANGES と ChangeLog ファイルを同じ意味で使わないでください。
       プロジェクトによっては、"CHANGELOG" ではなく、
       "NEWS" というファイル名を使うところもあります。
       こうすることで "ChangeLog" との混同は避けられますが、
       この名前はぴったり来る名前ではありません。なぜなら、
       CHANGES ファイルは全てのリリースの変更点を保持しているので、
       先頭に書いてある最新のニュースに加えて、
       たくさんの古いニュースも掲載することになるからです。
   </p><p>
       ChangeLog ファイルは、どちらにせよ徐々に消えつつあるものかもしれません。
       このファイルはCVSがバージョン管理システムの唯一の選択肢だった時代には役に立つものでした。
       なぜなら、CVSでは変更点の情報が展開しにくかったからです。
       しかし、最近のバージョン管理システムを使うと、
       ChangeLogで保存されていたデータは、
       バージョン管理システムのリポジトリに要求することでいつでも引き出すことができます。
       これによって、プロジェクトが変更点を静的なファイルに保存する意味がなくなります。
       — 実際には、リポジトリに保存されたログメッセージは、
       ChangeLog ファイルの内容と重複するだけなので、もっと無意味なことが起こります。
   </p></div><p>
    ツリーにあるソースコードのレイアウトは、
    バージョン管理システムのリポジトリから直接プロジェクトをチェックアウトしたときに得られるものと同じか、
    できるだけ似たものにすべきです。
    これらの間には少し違いがあるのが普通です。
    たとえば、リリースされるパッケージには設定やコンパイルに必要な自動生成されたファイル(<span>この章の後半の</span><a class="xref" href="ch07s04.html#packaging-build-install" title="コンパイルとインストール">「コンパイルとインストール」</a> を参照してください) が含まれていたり、
    プロジェクトが管理していないが、必須のものであったり、
    ユーザーがまだインストールしていないかもしれないサードパーティーのソフトウェアが含まれているからです。
    しかしながら、たとえ配布されたディレクトリツリーが、
    バージョン管理システムのリポジトリにある開発ツリーと全く同じだったとしても、
   その配布物は作業コピーと同じであってはいけません(<a class="xref" href="ch03s03.html#vc-vocabulary-working-copy"><em class="firstterm">作業コピー</em></a> を参照してください)。
    あるリリースは、開発ツリーへの静的な参照ポイントです。
    — これは特に、ある時点の固定されたソースファイルの設定 を表したものです。
    もし配布物が作業コピーと同じだと、ユーザーがそれを変更するかもしれません。
    また、実際に変更した後でリリースがあることを考えると危険です。
</p><p>
    パッケージの中身は、パッケージングのやり方に関わらず同じであることを忘れないでください。
    リリース—つまり、"Scanley 2.5.0" と呼ぶ場合に参照する正確なものは、
    zipやtarボールを展開したときに生成されるディレクトリツリーと同じです。
    よって、プロジェクトはこれら全てのフォーマットをダウンロード用に提供しても構いません。
</p><div class="informalexample"><div class="literallayout"><p>scanley-2.5.0.tar.bz2<br/>
scanley-2.5.0.tar.gz<br/>
scanley-2.5.0.zip</p></div></div><p>
    しかし、パッケージを展開して生成されるソースツリーは全て同じでなければなりません。
    このソースツリーは配布物です。つまり、ダウンロードするパッケージのフォーマットは、
    ユーザーの便宜のためだけに存在します。
    ソースパッケージにちょっとした違いがあっても許される場合があります。
    たとえば、Windows用のパッケージでは、
    テキストファイルの行はCRLF(キャリッジリターンとラインフィード)コードで終わるべきです。
    一方でUnix用のパッケージでは、LFで終了します。
    仮に異なったオペレーティングシステム間で違うコンパイル用のレイアウトが必要なら、
    異なったオペレーティングシステム用のソースパッケージでは、
    ソースツリーが少し異なっていても構いません。
    しかし、こうした違いは基本的にちょっとした変換で済ませるものです。
    基本的なソースファイルは、同じリリースのパッケージの範囲では同じにしておくべきです。
</p><div class="sect3" title="大文字にするか、小文字のままにするか"><div class="titlepage"><div><div><h3 class="title"><a id="release-capitalization"/>大文字にするか、小文字のままにするか</h3></div></div></div><p>
    プロジェクトの名前を引用する場合、普通は適当な名詞を大文字にし、
    もし頭文字だけを大文字にする単語があれば、そのようにします。
    たとえば "MySQL 5.0", "Scanley 2.5.0" などです。
    大文字の表現をパッケージ名でも使うかどうかは、プロジェクトによって異なります。
    たとえば、<code class="filename">Scanley-2.5.0.tar.gz</code> と <code class="filename">scanley-2.5.0.tar.gz</code> のどちらがよいか、ということです。(私は後者が好きです。
    なぜなら、シフトキーを人に打たせるのが嫌だからではなく、
    大文字を使うパッケージをたくさんのプロジェクトに出荷させることになるからです)
    重要なのは、tarボールを展開したときに作られるディレクトリが同じ名前を使っているかどうかです。
    ユーザーを驚かせないようにすべきです。つまり、配布物を展開して生成されるディレクトリ名は、
    ユーザーが正確に予測できるようにしておかなければなりません。
</p></div><div class="sect3" title="プレリリース版"><div class="titlepage"><div><div><h3 class="title"><a id="release-prereleases"/>プレリリース版</h3></div></div></div><p>
    プレリリース版またはリリース候補のパッケージをリリースする場合は、
    その識別子はリリース番号の一部になります。
    よって、パッケージ名にその識別子を含めるようにしましょう。
    たとえば、<a class="xref" href="ch07.html#release-number-components" title="リリース番号の構成要素">「リリース番号の構成要素」</a> で説明したアルファ版やベータ版のリリースの順番は、パッケージ名では以下のように表現します。
</p><div class="informalexample"><div class="literallayout"><p>scanley-2.3.0-alpha1.tar.gz<br/>
scanley-2.3.0-alpha2.tar.gz<br/>
scanley-2.3.0-beta1.tar.gz<br/>
scanley-2.3.0-beta2.tar.gz<br/>
scanley-2.3.0-beta3.tar.gz<br/>
scanley-2.3.0.tar.gz</p></div></div><p>
    はじめのパッケージは、<code class="filename">scanley-2.3.0-alpha1</code>というディレクトリに展開され、ふたつめは <code class="filename">scanley-2.3.0-alpha2</code> に展開される ... などです。
</p></div></div><div class="sect2" title="コンパイルとインストール"><div class="titlepage"><div><div><h2 class="title"><a id="packaging-build-install"/>コンパイルとインストール</h2></div></div></div><p>
    ソースコードをコンパイルし、インストールを行う必要があるソフトウェアは、
    経験豊富なユーザーが従う標準的な手順があります。
    たとえば、C, C++, その他のコンパイル言語で書かれたプログラムでは、
    Unixライクなシステムでユーザーがタイプする標準的な手順は次のようなものです。
</p><pre class="screen">
   $ ./configure
   $ make
   # make install
</pre><p>
    はじめのコマンドは、自動的に実行環境をできるだけ把握し、ビルドの準備を行います。
    ふたつめのコマンドはソフトウェアをビルドします。（しかしインストールは行いません）
    最後のコマンドはシステムにソフトウェアをインストールします。
    最初のふたつのコマンドは通常のユーザーで実行し、最後はrootユーザーで実行します。
    このシステムをセットアップする作業の詳細は、Vaughan, Elliston, Tromey,
    Taylor が書いた <em class="citetitle">GNU Autoconf, Automake,
    and Libtool</em> という優れた本があるので、それを参照してください。
    この本は 出版社 New Riders によってツリーウェア<sup>[<a id="idm2527" href="#ftn.idm2527" class="footnote">27</a>]</sup>として公開されており、
    <a class="ulink" href="http://sources.redhat.com/autobook/">http://sources.redhat.com/autobook/</a> でもオンラインで利用可能です。
</p><p>
    この手順が唯一の標準というわけではありませんが、
    もっとも普及しているもののひとつです。
    Ant (<a class="ulink" href="http://ant.apache.org/">http://ant.apache.org/</a>) ビルドシステムが特にJavaで書かれたプロジェクトで人気を得つつありますが、Antもビルドとインストールの標準的な手順を持っています。
    同様に、PerlやPythonのようなプログラミング言語では、
    その言語で書かれた殆どのプログラムで同じ手順を使うことを勧めています(たとえば、Perlモジュールは次のようなコマンドを使います。
    <span class="command"><strong>perl Makefile.PL</strong></span>)
    自分のプロジェクトにどの標準を使うかがわからない場合は、
    経験豊富な開発者に尋ねてみましょう<sup>[<a id="idm2533" href="#ftn.idm2533" class="footnote">28</a>]</sup>。
    たとえどの標準を使うかがはじめわからなくても、
    適用できる標準が <span class="emphasis"><em>存在する</em></span> と思っても大丈夫です。
</p><p>
    自分のプロジェクトに適した標準が何であれ、
    やむを得ない場合以外はそれを破ってはいけません。
    標準的なインストール手順は、たくさんのシステム管理者が反射的に実践しているものです。
    プロジェクトの <code class="filename">INSTALL</code>ファイル に自分が馴染んだ手順が書かれているのがわかれば、
    このプロジェクトは標準的な規約を守っているという信頼をすぐに得られます。
    標準的な手順をドキュメントに記すことで、他のことも理解しやすくなるでしょう。
    また、<span><a class="xref" href="ch02.html" title="第2章 さあ始めましょう">2章<em>さあ始めましょう</em></a>の</span> <a class="xref" href="ch02.html#downloads" title="ダウンロード">「ダウンロード」</a> でも議論していますが、
    標準的なビルド手順があると、開発者になる可能性がある人も喜んでくれます。
</p><p>
    Windows では、ビルドとインストールの標準的な手順がUnixライクなシステムほど決まっているわけではありません。
    コンパイルする必要があるプロジェクトでは、
    Microsoft の標準的な開発環境(Developer Studio, Visual Studio, VS.NET, MSVC++,
    など)の ワークスペース/プロジェクトモデルに合った形でソースツリーをリリースすることが標準的な規約のようです。
    ソフトウェアの性質にもよりますが、Cygwin環境(<a class="ulink" href="http://www.cygwin.com/">http://www.cygwin.com/</a>)経由でUnixライクなビルドオプションを提供することもできるでしょう。
    もちろん、自前のビルドとインストール手順があるプログラミング言語やフレームワーク—e.g Perl や Python のような— があるときは、
    環境が Windows, Unix, Mac OS X, あるいは他のオペレーティングシステム上であっても、
    それが提供している標準的な手順を採用すべきです。
</p><p>
    標準的なビルド、インストール手順にプロジェクトを合わせる努力を惜しまないようにしましょう。
    ビルドとインストールはソフトウェアを使う入口となる作業です。
    それを終えたら、やむを得ないならソフトウェアが扱いにくくてもよいのです。
    しかし、ユーザーや開発者がソフトウェアに触れる最初の段階で、
    予想外の手順を踏む必要があるなら、それは恥ずかしいことなのです。
</p></div><div class="sect2" title="バイナリパッケージ"><div class="titlepage"><div><div><h2 class="title"><a id="binary-packages"/>バイナリパッケージ</h2></div></div></div><p>
    ソースコードをパッケージングしてリリースするのが正式なやり方ですが、
    ほとんどのユーザーは、オペレーティングシステムのソフトウェア配布システムや、
    プロジェクト自体や、サードパーティーから取得したバイナリパッケージをインストールします。
    ここでいう "バイナリ" というのは必ずしも "コンパイルして生成したもの" という意味ではありません。
    ここでは単に、ソースコードをビルドしてインストールする手順を経ずに、
    コンピューターにインストールすることができる設定済みのパッケージのことをいいます。
    RedHat GNU/Linux では、その仕組みはRPMシステムと呼ばれ、Debian GNU/Linux では、
    APT (<code class="filename">.deb</code>) システムといいます。Microsoft Windows では、
    <code class="literal">.MSI</code> ファイル や、実行すればインストールを行ってくれる <code class="literal">.exe</code> ファイルであることが普通です。
</p><p>
    バイナリパッケージを作る人がプロジェクトに深く関わっている人であれ、
    サードパーティーであれ、
    ユーザーはそれらをプロジェクトの公式なリリースとして<span class="emphasis"><em>扱い</em></span>、
    バイナリパッケージの振る舞いをベースにしてバグ報告システムに問題を登録してきます。
    よって、パッケージャーに明確なガイドラインを提供し、
    彼らが提供するパッケージが、
    プロジェクトのソフトウェアを適切に表現してくれるように、
    彼らと緊密に連携することがプロジェクトの関心事になります。
</p><p>
    パッケージャーが主に知っておくべきことは、生成するバイナリパッケージは、
    プロジェクトからリリースされたオフィシャルなソースコードを元にすべきだということです。
    ユーザーにバグ修正や機能追加を提供するために、
    パッケージャーはソースコードリポジトリのコピーや、
    リリース後にコミットされた修正を選んでバイナリパッケージに取り込むことがあります。
    しかしこうした習慣は、実際には多くの混乱を引きおこします。
    プロジェクトはリリース済みのバージョンで見つかったバグ報告や、
    最近の trunk や主要なブランチのソースコードのバグ報告（つまり、
    注意深く最先端のコードを実行している人が見つけたバグ）を受け付ける準備をしています。
    バグ報告があがってくると、
    応答する人はそのバグがある時点のスナップショットで発生したということや、
    修正済みであること、そしてユーザーがアップグレードすべきか、
    次のリリースを待つべきかを確認することができます。
    仮にまだ報告されていないバグの場合は、
    リリースの時点が明確であれば、
    それの再現やバグ報告システム上でのバグの分類もやりやすくなります。
</p><p>
    しかしながら、ユーザーが改造を加えたものや、
    バージョンが決まっていない中間的なコードに対するバグ報告は、
    プロジェクトは受け付ける準備ができていません。こうした報告は再現させるのが難しく、
    後の開発で加えられる別の変更に予想外の影響を与える可能性もあります。
    このため、開発者が責任を取る必要がない不正な振舞いをソフトウェアが起こしてしまうのです。
    過去に発生していたはずのバグが <span class="emphasis"><em>発生しなくなってしまった</em></span> ために、
    多くの時間を浪費してしまってげんなりしたことがあります。
    これはユーザーが公式のリリース(全く同じではない)にちょっと改造を加えたバージョンを使っていたためです。
    バグが発生しなかったのが予想外だったので、
    開発者全員がその理由を調べるために詳細な調査をしなければなりませんでした。
</p><p>
    さらに、リリースされたソースコードには変更が必要だとパッケージャーが主張することもあります。
    パッケージャーは、プロジェクトの開発者にこうした変更を報告し、変更の計画を説明すべきです。
    パッケージャーが加えた変更は、開発者が受け入れてくれるかもしれませんが、
    受け入れてもらえなくても、自分がソースコードに変更を加える理由をプロジェクトに知らせておくべきです。
    これは、プロジェクトが予想外のバグ報告を見張ることができるようにするためです。
    開発者はプロジェクトのウェブサイトに免責事項を記載することで、
    こうしたバグ報告に対応してもよいでしょう。また、バイナリパッケージのユーザーに、
    自分たちが使っているパッケージがプロジェクトが公式にリリースしたものとは正確に同じものではないことを知らせるために、
    適切な場所で作業をするようにパッケージャーに求めることもできます。
    こういう状況で、パッケージャーと開発者がいがみ合う必要はありませんが、
    残念なことに対立してしまうこともあります。
    パッケージャーは、目指すものが開発者と少し違うだけなのです。
    パッケージャーはユーザーがインストールすればすぐに使えるものを主に求めています。
    開発者ももちろんそれを追求してはいますが、彼らは一貫したバグ報告を受付け、
    互換性を保証するためにパッケージャーが使っているバージョンを知らなればいけません。
    このふたつの目標はたびたび対立します。対立が起きたときには、
    プロジェクトはパッケージャーを拘束していないし、パッケージャーと開発者は、
    持ちつ持たれつの関係にあることを思い出すとよいでしょう。
    プロジェクトは、ソフトウェアを作るだけであっても、
    パッケージャーにとって良いことをしているのは事実です。
    しかし、パッケージャーもユーザーにソフトウェアを広めるために地道な作業のほとんどをこなすことで、
    開発者にとってよいことをしているのです。この作業は、とてつもない数のユーザーを対象にすることもあります。パッケージャーに反対の意思を示すのはよいことですが、喧嘩をしてはいけません。
    開発者は自分が出せる最良のソフトウェアを世に送り出すことのみに注力すればよいのです。
</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.idm2527" href="#idm2527" class="para">27</a>] </sup>ドキュメントやその他の印刷物を指すハッカー用語</p></div><div class="footnote"><p><sup>[<a id="ftn.idm2533" href="#idm2533" class="para">28</a>] </sup> Python では <span class="command"><strong>python setup.py install</strong></span> という、Distutils を使った標準的なコマンドがあります。Ruby の場合は Rubygems 経由で <span class="command"><strong>gem install [パッケージ名]</strong></span> というコマンドを使います。</p></div></div></div></body></html>