<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Kontrola wersji</title><link rel="stylesheet" type="text/css" href="styles.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="Produkcja oprogramowania Open Source"><link rel="up" href="technical-infrastructure.html" title="Rozdzia&#322; 3. Infrastruktura techniczna"><link rel="prev" href="mailing-lists.html" title="Listy dyskusyjne"><link rel="next" href="bug-tracker.html" title="Bug Tracker"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Kontrola wersji</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="mailing-lists.html">Poprzedni</a> </td><th width="60%" align="center">Rozdzia&#322; 3. Infrastruktura techniczna</th><td width="20%" align="right"> <a accesskey="n" href="bug-tracker.html">Nast&#281;pny</a></td></tr></table><hr></div><div class="sect1" title="Kontrola wersji"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="vc"></a>Kontrola wersji</h2></div></div></div><p><em class="firstterm">System kontroli wersji</em> (ang.
    <em class="firstterm">version control system</em> lub <em class="firstterm">revision
        control system</em>) to zestaw narz&#281;dzi do &#347;ledzenia i
    kontrolowania zmian w plikach projektu, w szczególno&#347;ci w kodzie
    &#378;ród&#322;owym, dokumentacji i stronach WWW. Je&#347;li nigdy nie korzysta&#322;e&#347; z
    kontroli wersji, powiniene&#347; jak najpr&#281;dzej znale&#378;&#263; kogo&#347;, kto korzysta&#322;,
    i przekona&#263; go, aby do&#322;&#261;czy&#322; do projektu. W dzisiejszych czasach ka&#380;dy
    spodziewa si&#281;, &#380;e przynajmniej kod &#378;ród&#322;owy projektu znajduje si&#281; pod
    kontrol&#261; wersji, i nie traktuje powa&#380;nie projektów, które nie korzystaj&#261;
    z niej przynajmniej minimalnie umiej&#281;tnie.</p><p>Kontrola wersji jest tak uniwersalna, poniewa&#380; pomaga praktycznie w
    ka&#380;dym aspekcie projektu: komunikacji mi&#281;dzy programistami, zarz&#261;dzaniu
    wydaniami, &#347;ledzeniu b&#322;&#281;dów, stabilizacji kodu czy eksperymentowaniu,
    mo&#380;e tak&#380;e s&#322;u&#380;y&#263; do uwierzyteniania i przypisywania zas&#322;ug
    poszczególnym programistom. System kontroli wersji stanowi centralny
    punkt we wszystkich wspomnianych obszarach. Sercem kontroli wersji jest
    <em class="firstterm">zarz&#261;dzanie zmianami</em>, pozwalaj&#261;ce odró&#380;ni&#263; ka&#380;d&#261;
    atomow&#261; zmian&#281; w plikach projektu, metadane z ni&#261; zwi&#261;zane (jak data i
    autor danej zmiany) i przekaza&#263; j&#261; do innych u&#380;ytkowników w sposób, w
    jaki sobie tego za&#380;ycz&#261;. To kana&#322; komunikacyjny, w którym podstawow&#261;
    jednostk&#261; informacji jest pojedyncza zmiana.</p><p>Ten rozdzia&#322; nie omawia wszystkich aspektów korzystania z systemu
    kontroli wersji. To tak rozleg&#322;y temat, &#380;e przy okazji omawiania innych
    kwestii b&#281;dziemy do niego wracali jeszcze nie raz w tej ksi&#261;&#380;ce. Tutaj
    skupimy si&#281; na wybraniu i konfiguracji systemu kontroli wersji w taki
    sposób, który wspiera wspó&#322;prac&#281; nad rozwojem projektu.</p><div class="sect2" title="S&#322;ownictwo kontroli wersji"><div class="titlepage"><div><div><h3 class="title"><a name="vc-vocabulary"></a>S&#322;ownictwo kontroli wersji</h3></div></div></div><p>Ta ksi&#261;&#380;ka nie mo&#380;e nauczy&#263; ci&#281; kontroli wersji, je&#347;li nigdy wcze&#347;niej
    z niej nie korzysta&#322;e&#347;. Z drugiej strony trudno by&#322;oby rozmawia&#263; o niej
    bez wprowadzenia kilku podstawowych poj&#281;&#263;. Te poj&#281;cia s&#261; niezale&#380;ne od
    konkretnego systemu kontroli wersji, to podstawowe rzeczowniki i
    przymiotniki gdy wspó&#322;pracujemy w sieci, i b&#281;d&#261; cz&#281;sto stosowane w
    dalszej cz&#281;&#347;ci ksi&#261;&#380;ki. Nawet gdyby nie wymy&#347;lono systemów kontroli
    wersji, problem zarz&#261;dzania zmianami ci&#261;gle by istnia&#322;&#8212;a wi&#281;c
    potrzebujemy j&#281;zyka, pozwalaj&#261;cego mówi&#263; o problemie w zwi&#281;z&#322;y sposób.

</p><div class="variablelist"><div class="sidebar" title='Wieloznaczno&#347;&#263; s&#322;owa "wersja"'><a name="version-vs-revision"></a><div class="titlepage"><div><div><p class="title"><b>Wieloznaczno&#347;&#263; s&#322;owa "wersja"</b></p></div></div></div><p>S&#322;owo wersja jest tak&#380;e u&#380;ywane w kontek&#347;cie "wersji
      oprogramowania", jak na przyk&#322;ad "wersja 1.0". Nale&#380;y odró&#380;ni&#263; wersj&#281;
      w tym znaczeniu, i w znaczeniu systemu kontroli
      wersji<sup>[<a name="idp6290496" href="#ftn.idp6290496" class="footnote">16</a>]</sup>.</p></div><dl><dt><a name="vc-vocabulary-commit"></a><span class="term"><em class="firstterm">commit</em></span></dt><dd><p>Dokona&#263; zmiany w projekcie. Bardziej formalnie, zapisa&#263;
          zmian&#281; w bazie danych systemu kontroli wersji w taki sposób, &#380;e
          mo&#380;e zosta&#263; w&#322;&#261;czona do przysz&#322;ych wyda&#324; projektu. "Commit" mo&#380;na
          stosowa&#263; jako czasownik lub rzeczownik<sup>[<a name="idp6262608" href="#ftn.idp6262608" class="footnote">14</a>]</sup>, jako rzeczownik to w
          zasadzie synonim "zmiany". Na przyk&#322;ad: "W&#322;a&#347;nie zrobi&#322;em commit
          poprawki dla b&#322;&#281;du powoduj&#261;cego problemy ze stabilno&#347;ci&#261; serwera,
          zg&#322;aszanego przez u&#380;ytkowników Mac OS X. Jay, móg&#322;by&#347; przejrze&#263;
          commit i sprawdzi&#263;, czy dobrze u&#380;ywam w niej
          alokatora?"</p></dd><dt><a name="vc-vocabulary-log-message"></a><span class="term"><em class="firstterm">komentarz do zmiany</em> (ang.
         <em class="firstterm">log message</em>)</span></dt><dd><p>Krótka wiadomo&#347;&#263; do&#322;&#261;czona do ka&#380;dego commita,
             opisuj&#261;ca jego natur&#281; i cel. Komentarze do zmian to jedne z
             najwa&#380;niejszych dokumentów ka&#380;dego projektu, stanowi&#261; most
             pomi&#281;dzy bardzo technicznym j&#281;zykiem samego kodu, a bardziej
             zorientowanym na u&#380;ytkownika j&#281;zykiem mówi&#261;cym o zadaniach,
             poprawkach b&#322;&#281;dów i post&#281;pie projektu. Dalej w tym rozdziale
             omówimy sposoby dystrybucji komentarzy zmian do odpowiednich
             odbiorców. Co wi&#281;cej, <a class="xref" href="growth.html#codifying-tradition" title="Codifying Tradition">&#8222;Codifying Tradition&#8221;</a><span> w
                 <a class="xref" href="communications.html" title="Rozdzia&#322; 6. Communications">Rozdzia&#322; 6, <i>Communications</i></a></span> mówi o tym, jak
             zach&#281;ci&#263; uczestników projektu do pisania zwi&#281;z&#322;ych i
             u&#380;ytecznych komentarzy do zmian.</p></dd><dt><a name="vc-vocabulary-update"></a><span class="term"><em class="firstterm">aktualizacja</em> (ang.
         <em class="firstterm">update</em>)</span></dt><dd><p>Aktualizacja to do&#322;&#261;czenie zmian dokonanych przez
             innych do lokalnej kopii projektu, a wi&#281;c sprawienie, aby kopia
             sta&#322;a si&#281; aktualna. To bardzo cz&#281;sta czynno&#347;&#263;, wi&#281;kszo&#347;&#263;
             programistów aktualizuje swój kod wiele razy dziennie, aby mie&#263;
             pewno&#347;&#263;, &#380;e pracuj&#261; mniej-wi&#281;cej na tej samej wersji kodu, co
             pozostali. Co wi&#281;cej, gdy znajd&#261; b&#322;&#261;d, mog&#261; by&#263; niemal pewni, &#380;e
             nie zosta&#322; on jeszcze naprawiony. Na przyk&#322;ad: "Hej,
             zauwa&#380;y&#322;em, &#380;e kod indeksuj&#261;cy zawsze wyrzuca ostatni bajt. Czy
             to nowy b&#322;&#261;d?" "Tak, ale zosta&#322; ju&#380; naprawiony tydzie&#324;
             temu&#8212;zrób aktualizacj&#281;, powinien
             znikn&#261;&#263;."</p></dd><dt><a name="vc-vocabulary-repository"></a><span class="term"><em class="firstterm">repozytorium</em> (ang.
         <em class="firstterm">repository</em>)</span></dt><dd><p>Baza danych, w której zapisywane s&#261; zmiany. Niektóre
             systemy wersji s&#261; zcentralizowane: istnieje jedno g&#322;ówne
             repozytorium, przechowuj&#261;ce wszystkie zmiany. Inne s&#261;
             zdecentralizowane: ka&#380;dy programista ma swoje w&#322;asne
             repozytorium, a zmiany mog&#261; by&#263; dowolnie przenoszone pomi&#281;dzy
             repozytoriami. System kontroli wersji &#347;ledzi zale&#380;no&#347;ci
             pomi&#281;dzy zmianami, i gdy nadejdzie czas wydania, odpowiedni
             zestaw zmian zostaje zaakceptowany do nowej wersji. Pytanie czy
             lepsze s&#261; systemy zcentralizowane czy rozproszone to jedna z
             wci&#261;&#380; &#380;ywych programistycznych &#347;wi&#281;tych wojen, postaraj si&#281;
             unika&#263; k&#322;ótni na ten temat na listach dyskusyjnych
             projektu.</p></dd><dt><a name="vc-vocabulary-checkout"></a><span class="term"><em class="firstterm">checkout</em></span></dt><dd><p>Proces pobierania kopii projektu z repozytorium.
          Checkout<sup>[<a name="idp6278272" href="#ftn.idp6278272" class="footnote">15</a>]</sup> zazwyczaj tworzy drzewo podkatalogów,
          nazywane "kopi&#261; robocz&#261;" (patrz ni&#380;ej), w której zmiany mog&#261; by&#263;
          wysy&#322;ane do repozytorium (jako commit). W niektórych
          zdecentralizowanych systemach kontroli wersji ka&#380;da kopia robocza
          jest zarazem repozytorium, a zmiany mog&#261; by&#263; wypychane z (lub
          wci&#261;gane do) ka&#380;dego repozytorium, które je
          zaakceptuje.</p></dd><dt><a name="vc-vocabulary-working-copy"></a><span class="term"><em class="firstterm">kopia robocza</em> (<em class="firstterm">ang. working
             copy</em>)</span></dt><dd><p>Prywatne drzewo katalogów ka&#380;dego programisty,
             zawieraj&#261;ce kod &#378;ród&#322;owy projektu i by&#263; mo&#380;e jego stron&#281; WWW,
             czy inne dokumenty. Kopia robocza zawiera tak&#380;e pewn&#261; ilo&#347;&#263;
             metadanych, zarz&#261;dzanych przez system kontroli wersji,
             okre&#347;laj&#261;cych z jakiego repozytorium pochodzi, jakie "wersje"
             (patrz ni&#380;ej) plików s&#261; obecne, itd. Na ogó&#322; ka&#380;dy programista
             ma swoj&#261; w&#322;asn&#261; kopi&#281; robocz&#261;, w której dokonuje zmian i je
             testuje, i z której wykonuje commit.</p></dd><dt><a name="vc-vocabulary-revision"></a><span class="term"><em class="firstterm">wersja</em> (ang.
         <em class="firstterm">revision</em>), <em class="firstterm">zmiana</em>
         (ang. <em class="firstterm">change</em>), <em class="firstterm">zbiór
             zmian</em> (ang.
         <em class="firstterm">changeset</em>)</span></dt><dd><p>"Wersja" to na ogó&#322; konkretne wcielenie danego pliku
             lub katalogu. Na przyk&#322;ad plik F mo&#380;e by&#263; najpierw w wersji 6,
             nast&#281;pnie kto&#347; wykonuje commit zmieniaj&#261;cy plik F, tworz&#261;c
             wersj&#281; 7 pliku F. Niektóre systemy stosuj&#261; poj&#281;cia "wersja",
             "zmiana" czy "zbiór zmian" aby opisa&#263; zbiór zmian, wys&#322;anych w
             jednym commicie jako jedna abstrakcyjna operacja.</p><p>Niekiedy te poj&#281;cia maj&#261; ró&#380;ne znaczenia w poszczególnych
             systemach kontroli wersji, ale sama idea pozostaje bez zmian:
             pozwalaj&#261; one mówi&#263; precyzyjnie o pewnych punktach w czasie
             historii pliku lub zbioru plików (na przyk&#322;ad przed i po
             poprawce jakiego&#347; b&#322;&#281;du). Na przyk&#322;ad: "Tak, naprawi&#322;a to w
             wersji 10" lub "Naprawi&#322;a to w wersji 10 pliku foo.c".</p><p>Gdy kto&#347; mówi o pliku lub grupie plików bez wspominania o
             konkretnej wersji, na ogó&#322; zak&#322;ada si&#281;, &#380;e ma na my&#347;li jego
             (ich) najnowsz&#261; wersj&#281; dost&#281;pn&#261; w
             repozytorium.</p></dd><dt><a name="vc-vocabulary-diff"></a><span class="term"><em class="firstterm">diff</em></span></dt><dd><p>Tekstowa reprezentacja zmiany. Diff wskazuje, które linie
          uleg&#322;y zmianie i w jaki sposób, pokazuj&#261;c przy okazji kilka linii
          kontekstu przed i po. Programista, który zna dany obszar kodu mo&#380;e
          na ogó&#322; przeczyta&#263; diff i zrozumie&#263;, na czym polega zmiana, a by&#263;
          mo&#380;e nawet wy&#322;apa&#263; b&#322;&#281;dy.</p></dd><dt><a name="vc-vocabulary-tag"></a><span class="term"><em class="firstterm">etykieta</em> (ang.
         <em class="firstterm">tag</em>)</span></dt><dd><p>Okre&#347;la pewien zbiór plików w &#347;ci&#347;le okre&#347;lonych
             wersjach. Etykiety sa na ogó&#322; u&#380;ywane do oznaczania wa&#380;nych
             momentów w &#380;yciu projektu. Na przyk&#322;ad etykieta jest na ogó&#322;
             tworzona dla ka&#380;dego publicznego wydania, tak, aby ka&#380;dy móg&#322;
             pobra&#263; bezpo&#347;rednio z repozytorium dok&#322;adnie te same wersje
             plików, które zosta&#322;y wydane. Popularnymi nazwami etykiet s&#261; na
             przyk&#322;ad <code class="literal">Release_1_0</code>,
             <code class="literal">Delivery_00456</code>, itd.</p></dd><dt><a name="vc-vocabulary-branch"></a><span class="term"><em class="firstterm">ga&#322;&#261;&#378;</em> (ang.
         <em class="firstterm">branch</em>)</span></dt><dd><p>Kopia projektu znajduj&#261;ca si&#281; w repozytorium, ale
             izolowana w taki sposób, &#380;e zmiany w ga&#322;&#281;zi nie wp&#322;ywaj&#261; na
             reszt&#281; projektu, i odwrotnie, do czasu gdy zmiany nie zostan&#261;
             przez kogo&#347; "scalone" (patrz ni&#380;ej). Ga&#322;&#281;zie bywaj&#261; tak&#380;e
             nazywane "liniami rozwoju". Nawet gdy projekt nie posiada wielu
             ga&#322;&#281;zi, mówi si&#281; &#380;e rozwój odbywa si&#281; na "g&#322;ównej ga&#322;&#281;zi",
             tak&#380;e nazywanej "<em class="firstterm">pniem</em>" (ang.
             <em class="firstterm">trunk</em>).</p><p>Ga&#322;&#281;zie daj&#261; mo&#380;liwo&#347;&#263; odizolowania od siebie ró&#380;nych linii
             rozwoju. Na przyk&#322;ad ga&#322;&#261;&#378; mo&#380;e powsta&#263; na potrzeby
             eksperymentalnego kodu, który móg&#322;by zdestabilizowa&#263; g&#322;ówn&#261;
             ga&#322;&#261;&#378;. Albo odwrotnie, ga&#322;&#261;&#378; mo&#380;e by&#263; u&#380;yta jako miejsce, w
             którym nowe wydanie b&#281;dzie stabilizowane. Podczas procesu
             wydania normalny rozwój mo&#380;e odbywa&#263; si&#281; w g&#322;ównej ga&#322;&#281;zi
             repozytorium, a w tym samym czasie na ga&#322;&#281;zi utworzonej dla
             wydania nie b&#281;d&#261; akceptowane &#380;adne zmiany oprócz tych, które
             zosta&#322;y dozwolone przez zarz&#261;dzaj&#261;cych wydaniem. W ten sposób
             wydanie nowej wersji nie musi kolidowa&#263; z normalnym rozwojem.
             Patrz <a class="xref" href="vc.html#branches" title="Use branches to avoid bottlenecks">&#8222;Use branches to avoid bottlenecks&#8221;</a><span> dalej
                 w tym rozdziale</span> aby dowiedzie&#263; si&#281; wi&#281;cej o
             ga&#322;&#281;ziach.</p></dd><dt><a name="vc-vocabulary-merge"></a><span class="term"><em class="firstterm">scalanie lub portowanie</em> (ang.
         <em class="firstterm">merge</em> lub
         <em class="firstterm">port</em>)</span></dt><dd><p>Przeniesienie zmiany z jednej ga&#322;&#281;zi na inn&#261;. Chodzi
             zarówno o scalanie zmian z g&#322;ównej ga&#322;&#281;zi do innej ga&#322;&#281;zi, jak
             i w drug&#261; stron&#281;. To najcz&#281;&#347;ciej stosowane w praktyce rodzaje
             scale&#324;&#8212;rzadko przenosi si&#281; zmiany pomi&#281;dzy dwoma
             ga&#322;&#281;ziami, z których &#380;adna nie jest g&#322;ówn&#261;. Patrz <a class="xref" href="vc.html#vc-singularity" title="Singularity of information">&#8222;Singularity of information&#8221;</a> oby dowiedzie&#263; si&#281; wi&#281;cej o
             takich scalaniach.</p><p>"Scalanie" ma jeszcze drugie, podobne znaczenie: to
             zachowanie systemu kontroli wersji gdy stwierdzi, &#380;e dwóch
             u&#380;ytkowników dokona&#322;o zmian w tym samym pliku, które nie
             zachodz&#261; na siebie. Takie zmiany na ogó&#322; nie maj&#261; na siebie
             wp&#322;ywu, wi&#281;c u tego u&#380;ytkownika, który dokona aktualizacji
             pliku (w którym sam dokona&#322; zmian), zmiany innych zostan&#261;
             automatycznie scalone. To bardzo cz&#281;sta sytuacja, szczególnie w
             projektach, w których wiele osób pracuje nad tym samym kodem.
             Gdy dwie ró&#380;ne zmiany <span class="emphasis"><em>zachodz&#261;</em></span> na siebie,
             pojawia si&#281; "konflikt" (patrz ni&#380;ej).</p></dd><dt><a name="vc-vocabulary-conflict"></a><span class="term"><em class="firstterm">konflikt</em> (ang.
         <em class="firstterm">conflict</em>)</span></dt><dd><p>Konflikt zachodzi, gdy dwie osoby próbuj&#261; dokona&#263; zmian
             dok&#322;adnie w tym samym miejscu kodu. Wszystkie systemy kontroli
             wersji automatycznie wykrywaj&#261; konflikty i powiadamiaj&#261; jednego
             z u&#380;ytkowników o ich istnieniu. Reszta jest w r&#281;kach cz&#322;owieka,
             musi on r&#281;cznie <em class="firstterm">rozwi&#261;za&#263;</em> (ang.
             <em class="firstterm">resolve</em>) konflikt i poinformowa&#263; o tym
             system kontroli wersji.</p></dd><dt><a name="vc-vocabulary-lock"></a><span class="term"><em class="firstterm">blokada</em> (ang.
         <em class="firstterm">lock</em>)</span></dt><dd><p>Sposób na zadeklarowanie wy&#322;&#261;czno&#347;ci na zmiany w danym
             pliku lub katalogu. Na przyk&#322;ad: "Nie mog&#281; zrobi&#263; commitu moich
             zmian w stronach WWW. Wygl&#261;da na to, &#380;e Alfred za&#322;o&#380;y&#322; blokad&#281;
             na czas poprawek w obrazkach t&#322;a." Nie wszystkie systemy
             kontroli wersji pozwalaj&#261; na stosowanie blokad, a z tych które
             pozwalaj&#261;, nie wszystkie wymagaj&#261; korzystania z nich. To
             dlatego, &#380;e równoleg&#322;y wspólny rozwój jest standardem, a
             blokowanie plików przed zmianami innych jest (na ogó&#322;)
             sprzeczne z t&#261; ide&#261;.</p><p>Mówi si&#281;, &#380;e systemy kontroli wersji, które wymagaj&#261;
             stosowania blokad aby wykona&#263; commit, pracuj&#261; w modelu
             <em class="firstterm">blokada-modyfikacja-odblokowanie</em>. Te,
             które ich nie wymagaj&#261; stosuj&#261; model
             <em class="firstterm">kopia-modyfikacja-scalanie</em>. Doskona&#322;e
             wyja&#347;nienie i porównanie obu modeli mo&#380;na znale&#378;&#263; w <a class="ulink" href="http://svnbook.red-bean.com/svnbook-1.0/ch02s02.html" target="_top">http://svnbook.red-bean.com/svnbook-1.0/ch02s02.html</a>.
             Na ogó&#322; model kopia-modyfikacja-scalanie jest lepszy dla
             rozwoju otwartego oprogramowania, i wszystkie systemy kontroli
             wersji omówione w tym rozdziale wspieraj&#261; taki
             model.</p></dd></dl></div><p>

</p></div><div class="sect2" title="Wybór systemu kontroli wersji"><div class="titlepage"><div><div><h3 class="title"><a name="vc-choosing"></a>Wybór systemu kontroli wersji</h3></div></div></div><p>W chwili pisania tych s&#322;ów dwoma najpopularniejszymi systemami kontroli
wersji w &#347;wiecie wolnego oprogramowania si&#261; <em class="firstterm">CVS</em>
(<em class="firstterm">Concurrent Versions System</em>, <a class="ulink" href="http://www.cvshome.org/" target="_top">http://www.cvshome.org/</a>) i <em class="firstterm">SVN</em>
(<em class="firstterm">Subversion</em>, <a class="ulink" href="http://subversion.tigris.org/" target="_top">http://subversion.tigris.org/</a>).</p><p>CVS istnieje od bardzo dawna. Wi&#281;kszo&#347;&#263; do&#347;wiadczonych programistów jest
ju&#380; przyzwyczajona do korzystania z niego. Mniej wi&#281;cej spe&#322;ania swoje
zadanie i jest popularny od bardzo dawna, wi&#281;c wybieraj&#261;c CVS raczej nie
doprowadzisz do d&#322;ugiej dyskusji o tym, czy to dobry wybór. Jednak CVS ma
pewne wady. Nie pozwala na &#322;atwe odró&#380;nianie tego, &#380;e dana zmiana dotyczy&#322;a
wielu plików, nie pozwala na zmian&#281; nazwy czy kopiowanie plików pod kontrol&#261;
wersji (je&#347;li wi&#281;c potrzebujesz przeorganizowa&#263; struktur&#281; kodu w trakcie
projektu, masz problem), ma s&#322;abe wsparcie dla scalania, nie obs&#322;uguje dobrze
du&#380;ych plików ani plików binarnych, a niektóre operacje bywaj&#261; bardzo powolne,
gdy dotycz&#261; wielu plików.</p><p>&#379;adna z tych wad nie jest dyskwalifikuj&#261;ca, wi&#281;c CVS jest wci&#261;&#380; do&#347;&#263;
popularny. Jednak w ostatnich kilku latach system kontroli wersji Subversion
zacz&#261;&#322; zyskiwa&#263; zwolenników, szczególnie w nowszych
projektach.<sup>[<a name="idp6327792" href="#ftn.idp6327792" class="footnote">17</a>]</sup> Je&#347;li rozpoczynasz nowy
projekt, polecam Subversion.</p><p>Z drugiej strony jestem zaanga&#380;owany w projekt Subversion, wi&#281;c moja
    obiektywno&#347;&#263; mo&#380;e by&#263; kwestionowana. Co wi&#281;cej, w ostatnich latach
    pojawi&#322;o si&#281; wiele nowych systemów kontroli wersji na wolnych licencjach.
    <a class="xref" href="vc-systems.html" title="Dodatek A. Wolne Systemy Kontroli Wersji (VCS)">Dodatek A, <i>Wolne Systemy Kontroli Wersji (VCS)</i></a> zawiera list&#281; wszystkich, które znam,
    posortowanych wed&#322;ug (przybli&#380;onej) popularno&#347;ci. U&#347;wiadamia ona, &#380;e wybór
    systemu kontroli wersji mo&#380;e sta&#263; si&#281; projektem badawczym na ca&#322;e &#380;ycie.
    By&#263; mo&#380;e dylematów pozbawi Ci&#281; dostawca hostingu, je&#347;li jednak musisz
    wybiera&#263;, porozmawiaj z innymi programistami, zapytaj znajomych o ich
    do&#347;wiadczenia, a nast&#281;pnie wybierz jeden system i przy nim pozosta&#324;. Ka&#380;dy
    stabilny i gotowy do zastnowa&#324; produkcyjnych system kontroli wersji
    powinien wystarczy&#263;, nie musisz martwi&#263; si&#281; za bardzo skutkami swojej
    decyzji. Je&#347;li jednak nie mo&#380;esz si&#281; zdecydowa&#263;, skorzystaj z Subversion.
    Jest do&#347;&#263; &#322;atwy w nauce, i najprawdopodobniej pozostanie standardem przez
    przynajmniej kilka late.</p></div><div class="sect2" title="Korzystanie z systemu kontroli wersji"><div class="titlepage"><div><div><h3 class="title"><a name="vc-using"></a>Korzystanie z systemu kontroli wersji</h3></div></div></div><p>Rady w tym rozdziale nie dotycz&#261; jakiego&#347; konkretnego systemu kontroli
    wersji, ich zastosowanie powinno by&#263; &#322;atwe w ka&#380;dym z nich. Sprawd&#378;
    dokumentacj&#281; Twojego systemu kontroli wersji aby dowiedzie&#263; si&#281;
    wiecej.</p><div class="sect3" title="Wersjonuj wszystko"><div class="titlepage"><div><div><h4 class="title"><a name="version-everything"></a>Wersjonuj wszystko</h4></div></div></div><p>Kontrol&#281; wersji stosuj nie tylko dla kodu &#378;ród&#322;owego projeku, ale tak&#380;e
    strony internetowej, dokumentacji, FAQ, dokumentów projektowych i
    wszystkiego innego, co ludzie mogliby edytowa&#263;. Przechowuj je zaraz obok
    kodu, w tym samym repozytorium. Ka&#380;d&#261; informacj&#281;, któr&#261; warto zapisa&#263;,
    warto te&#380; wersjonowa&#263;&#8212;a wi&#281;c ka&#380;d&#261; informacj&#281;, która mo&#380;e ulec
    zmienie. Rzeczy które nie ulegaj&#261; zmianie powinny by&#263; archiwizowane, nie
    wersjonowane. Na przyk&#322;ad email po wys&#322;aniu nie mo&#380;e ju&#380; zmieni&#263; tre&#347;ci, a
    wi&#281;c kontrola wersji w tym przypadku nie mia&#322;aby sensu (do czasu, gdy nie
    stanie si&#281; cz&#281;&#347;ci&#261; jakiego&#347; wi&#281;kszego, ewoluj&#261;cego dokumentu).</p><p>Wersjonowanie wszystkiego razem, w jednym miejscu, jest tak wa&#380;ne, gdy&#380;
    wtedy ludzi musz&#261; nauczy&#263; si&#281; tylko jednego mechanizmu nadsy&#322;ania zmian.
    Cz&#281;sto uczestnik projektu zaczyna od edycji strony internetowej czy
    dokumentacji, a nast&#281;pnie stopniowo przechodzi do trudniejszych zada&#324;. Gdy
    projekt korzysta z tego samego systemu dla wszystkich zmian, ludzi musz&#261;
    nauczy&#263; si&#281; korzysta&#263; z niego jedynie raz. Wersjonowanie wszystkiego razem
    oznacza te&#380;, &#380;e commit nowego kodu mo&#380;e zawiera&#263; te&#380; aktualizacj&#281;
    dokumentacji, utworzenie ga&#322;&#281;zi kodu tworzy tak&#380;e ga&#322;&#261;&#378; dokumentacji, i
    tak dalej.</p><p>W przechowuj w repozytorium <em class="firstterm">plików generowanych</em>.
    Nie s&#261; one edytowalnymi danymi, gdy&#380; s&#261; generowane automatycznie na
    podstawie innych plików. Na przyk&#322;ad niektóre systemy budowania tworz&#261;
    plik <code class="filename">configure</code> w oparciu o szablon
    <code class="filename">configure.in</code>. Aby dokona&#263; zmian w pliku
    <code class="filename">configure</code> nale&#380;y wyedytowa&#263;
    <code class="filename">configure.in</code> i wygenerowa&#263; plik wynikowy, a wi&#281;c
    jedynie szablon jest "plikiem edytowalnym". Wersjonuj jedynie
    szablony&#8212;je&#347;li b&#281;dziesz wersjonowa&#263; tak&#380;e pliki wynikowe, ludzi b&#281;d&#261;
    zapomina&#263; o tym, aby je ponownie wygenerowa&#263; po dokonaniu zmian w
    szablonie, a wynikaj&#261;ce z tego niespójno&#347;ci b&#281;d&#261; prowadzi&#263; do sporego
    zamieszania.<sup>[<a name="idp6336736" href="#ftn.idp6336736" class="footnote">18</a>]</sup></p><p>Od zasady mówi&#261;cej, &#380;e wszystkie edytowalne dane powinny by&#263; przechowywane w
    systemie kontroli wersji, jest niestety jeden wyj&#261;tek: system &#347;ledzenia
    b&#322;&#281;dów. Bazy b&#322;&#281;dów zawieraj&#261; wiele edytowalnych danych, ale z powodów
    technicznych nie przechowuj&#261; ich w g&#322;ównym systemie kontroli wersji.
    Niektóre z nich maj&#261; w&#322;asne prymitywne mo&#380;liwo&#347;ci wersjonowania, s&#261; one
    jednak zupe&#322;nie niezale&#380;ne od g&#322;ównego repozytorium projektu.</p></div><div class="sect3" title="Mo&#380;liwo&#347;&#263; przegl&#261;dania"><div class="titlepage"><div><div><h4 class="title"><a name="vc-browsing"></a>Mo&#380;liwo&#347;&#263; przegl&#261;dania</h4></div></div></div><p>Repozytorium projektu powinno da&#263; si&#281; przegl&#261;da&#263; przy u&#380;yciu
    przegl&#261;darki internetowej. Nie chodzi tu tylko o mo&#380;liwo&#347;&#263; dost&#281;pu do
    najnowszych wersji plików, ale tak&#380;e cofanie si&#281; w czasie i podgl&#261;d
    starych wersji, porównywanie ró&#380;nic pomi&#281;dzy wersjami, czytania komentarzy
    do zmian, i tak dalej.</p><p>Mo&#380;liwo&#347;&#263; przegl&#261;dania jest istotna, poniewa&#380; daje mo&#380;liwo&#347;&#263; &#322;atwego
    dost&#281;pu do danych projektu. Gdyby repozytorium nie by&#322;o dost&#281;pne za pomoc&#261;
    przegl&#261;darki, wtedy ka&#380;dy kto chcia&#322;by sprawdzi&#263; zawarto&#347;&#263; jakiego&#347; pliku
    (na przyk&#322;ad aby sprawdzi&#263;, czy pewna poprawka zosta&#322;a do&#322;&#261;czona do kodu)
    musia&#322;by najpierw zainstalowa&#263; u siebie klienta systemu kontroli wersji,
    co mog&#322;oby zmieni&#263; kilkuminutowe zapytanie w pó&#322; godzinne zadanie.</p><p>Mo&#380;liwo&#347;&#263; przegl&#261;dania zak&#322;ada te&#380; istnienie standardowych adresów do
    przegl&#261;dania wybranych wersji plików, w&#322;&#261;czaj&#261;c w to t&#281; najnowsz&#261;. To mo&#380;e
    by&#263; bardzo przydatne w dyskusjach technicznych lub w odsy&#322;aczach do
    dokumentacji. Na przyk&#322;ad zamiast mówi&#263; "Aby znale&#378;&#263; porady dotycz&#261;ce
    debugowania serwera sprawd&#378; plik www/hacking.html w swojej kopii roboczej"
    mo&#380;na powiedzie&#263; "Aby znale&#378;&#263; porady dotycz&#261;ce debugowania serwera sprawd&#378;
    <span class="emphasis"><em>http://subversion.apache.org/docs/community-guide/</em></span>",
    podaj&#261;c adres wskazuj&#261;cy na najbardziej aktualn&#261; wersj&#281; pliku
    <code class="filename">hacking.html</code>. Adres URL jest lepszy, poniewa&#380; jest
    jednoznaczny i niezale&#380;ny od tego, na ile aktualn&#261; kopi&#281; robocz&#261; posiada
    adresat.</p><p>Niektóre systemy kontroli wersji posiadaj&#261; wbudowane mechanizmy do
    przegl&#261;dania repozytorium, inne polegaj&#261; na zewn&#281;trznych narz&#281;dziach.
    Takimi narz&#281;dziami s&#261; <em class="firstterm">ViewCVS</em> (<a class="ulink" href="http://viewcvs.sourceforge.net/" target="_top">http://viewcvs.sourceforge.net/</a>),
    <em class="firstterm">CVSWeb</em> (<a class="ulink" href="http://www.freebsd.org/projects/cvsweb.html" target="_top">http://www.freebsd.org/projects/cvsweb.html</a>), i
    <em class="firstterm">WebSVN</em> (<a class="ulink" href="http://websvn.tigris.org/" target="_top">http://websvn.tigris.org/</a>).
    Pierwszy z nich wspó&#322;pracuje zarówno z CVS jak i Subversion, drugi jedynie
    z CVS, a trzeci tylko i wy&#322;&#261;cznie z Subversion.</p></div><div class="sect3" title="Powiadomienia o commitach"><div class="titlepage"><div><div><h4 class="title"><a name="commit-emails"></a>Powiadomienia o commitach</h4></div></div></div><p>Ka&#380;dy commit do repozytorim powinien powodowa&#263; wys&#322;anie emaila
    zawieraj&#261;cego informacje o autorze zmian, czasie ich wykonania,
    zmodyfikowanych plikach i ró&#380;nicach w stosunku do wersji pierwotnej. Ten
    email powinien zosta&#263; wys&#322;any na specjaln&#261; list&#281; dyskusyjn&#261;, odr&#281;bn&#261; od
    tej, na której dyskutuj&#261; ludzie. Programi&#347;ci (i inne zainteresowane osoby)
    powinni by&#263; zach&#281;cani do subskrybowania tej listy, gdy&#380; jest to
    najefektywniejszy sposób na to, aby &#347;ledzi&#263; zmiany w projekcie na poziomie
    kodu. Oprócz oczywistych zalet takiego przegl&#261;du kodu (patrz <a class="xref" href="setting-tone.html#code-review" title="Practice Conspicuous Code Review">&#8222;Practice Conspicuous Code Review&#8221;</a>), takie powiadomienia wzmacniaj&#261; spo&#322;eczno&#347;&#263;,
    gdy&#380; tworz&#261; wspólne forum na którym ludzie mog&#261; reagowa&#263; na zdarzenia
    (commity) widoczne dla wszystkich innych.</p><p>Szczegó&#322;y konfiguracji powiadomie&#324; s&#261; zale&#380;ne od konkretnego systemu
    kontroli wersji, ale na ogó&#322; istnieje gotowy skrypt, który mo&#380;na w tym
    celu wykorzysta&#263;. Je&#347;li masz problemy z jego odnalezieniem, spróbuj
    poszuka&#263; w dokumentacji pod has&#322;em <em class="firstterm">hooks</em>, a w
    szczególno&#347;ci <em class="firstterm">post-commit hook</em> (w terminologii CVS
    <em class="firstterm">loginfo hook</em>). Nie ma przyj&#281;tego polskiego
    odpowiednika, wi&#281;c na potrzeby tego rozdzia&#322;u u&#380;yjemy bezpo&#347;redniego
    t&#322;umaczenia "hak". Haki post-commit pozwalaj&#261; na automatyczne wykonywanie
    pewnych zada&#324; w odpowiedzi na commi. Hak zostaje wykonany dla ka&#380;dego
    commita, otrzymuj&#261;c wszystkie konieczne informacje o nim&#8212;których
    mo&#380;e u&#380;y&#263; na przyk&#322;ad do wys&#322;ania emaila.</p><p>Czasem warto zmodyfikowa&#263; domy&#347;lne zachowanie gotowego skryptu
    wysy&#322;aj&#261;cego powiadomienia:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Some commit mailers don't include the actual diffs in the
  email, but instead provide a URL to view the change on the web using
  the repository browsing system.  While it's good to provide the URL,
  so the change can be referred to later, it is also
  <span class="emphasis"><em>very</em></span> important that the commit email include
  the diffs themselves.  Reading email is already part of people's
  routine, so if the content of the change is visible right there in
  the commit email, developers will review the commit on the spot,
  without leaving their mail reader.  If they have to click on a URL to
  review the change, most won't do it, because that requires a new
  action instead of a continuation of what they were already doing.
  Furthermore, if the reviewer wants to ask something about the
  change, it's vastly easier to hit reply-with-text and simply
  annotate the quoted diff than it is to visit a web page and
  laboriously cut-and-paste parts of the diff from web browser to
  email client.</p><p>(Of course, if the diff is huge, such as when a large body of
  new code has been added to the repository, then it makes sense to
  omit the diff and offer only the URL.  Most commit mailers can do
  this kind of limiting automatically.  If yours can't, then it's
  still better to include diffs, and live with the occasional huge
  email, than to leave the diffs off entirely.  Convenient reviewing
  and commenting is a cornerstone of cooperative development, much
  too important to do without.)</p></li><li class="listitem"><p>The commit emails should set their Reply-to header
  to the regular development list, not the commit email list.  That
  is, when someone reviews a commit and writes a response, their
  response should be automatically directed toward the human
  development list, where technical issues are normally discussed.
  There are a few reasons for this.  First, you want to keep all
  technical discussion on one list, because that's where people expect
  it to happen, and because that way there's only one archive to
  search.  Second, there might be interested parties not subscribed to
  the commit email list.  Third, the commit email list advertises
  itself as a service for watching commits, not for watching commits
  <span class="emphasis"><em>and</em></span> occasional technical discussions.  Those who
  subscribed to the commit email list did not sign up for anything but
  commit emails; sending them other material via that list would
  violate an implicit contract.  Fourth, people often write programs
  that read the commit email list and process the results (for
  display on a web page, for example).  Those programs are prepared to
  handle consistently-formatted commit emails, but not inconsistent
  human-written mails.</p><p>Note that this advice to set Reply-to does not contradict the
  recommendations in
  <a class="xref" href="mailing-lists.html#reply-to" title="Wielka debata o nag&#322;ówek Reply-to">&#8222;Wielka debata o nag&#322;ówek Reply-to&#8221;</a><span> earlier in
  this chapter</span>.  It's
  always okay for the <span class="emphasis"><em>sender</em></span> of a message to set
  Reply-to.  In this case, the sender is the version control system
  itself, and it sets Reply-to in order to indicate that the
  appropriate place for replies is the development mailing list, not
  the commit list.</p></li></ol></div><div class="sidebar" title="CIA: Another Change Publication Mechanism"><a name="cia"></a><div class="titlepage"><div><div><p class="title"><b>CIA: Another Change Publication Mechanism</b></p></div></div></div><p>Commit emails are not the only way to propagate change news.
Recently, another mechanism called CIA (<a class="ulink" href="http://cia.navi.cx/" target="_top">http://cia.navi.cx/</a>) has been developed.  CIA is a real-time
commit statistics aggregator and distributor.  The most popular use of
CIA is to send commit notifications to IRC channels, so that people
logged into those channels see the commits happening in real time.
Though of somewhat less technical utility than commit emails, since
observers might or might not be around when a commit notice pops up in
IRC, this technique is of immense <span class="emphasis"><em>social</em></span> utility.
People get the sense of being part of something alive and active, and
feel that they can see progress being made right before their
eyes.</p><p>The way it works is that you invoke the CIA notifier program
from your post-commit hook.  The notifier formats the commit
information into an XML message, and sends to a central server
(typically <code class="literal">cia.navi.cx</code>).  That server then
distributes the commit information to other forums.</p><p>CIA can also be configured to send out <a class="ulink" href="http://www.xml.com/pub/a/2002/12/18/dive-into-xml.html" target="_top">RSS</a>
feeds.  See the documentation at <a class="ulink" href="http://cia.navi.cx/" target="_top">http://cia.navi.cx/</a>
for details.</p><p>To see an example of CIA in action, point your IRC
client at <code class="literal">irc.freenode.net</code>, channel
<code class="literal">#commits</code>.</p></div></div><div class="sect3" title="Use branches to avoid bottlenecks"><div class="titlepage"><div><div><h4 class="title"><a name="branches"></a>Use branches to avoid bottlenecks</h4></div></div></div><p>Non-expert version control users are sometimes a bit afraid of
branching and merging.  This is probably a side effect of CVS's
popularity: CVS's interface for branching and merging is somewhat
counterintuitive, so many people have learned to avoid those
operations entirely.</p><p>If you are among those people, resolve right now to conquer any
fears you may have and take the time to learn how to do branching and
merging.  They are not difficult operations, once you get used to
them, and they become increasingly important as a project acquires
more developers.</p><p>Branches are valuable because they turn a scarce
resource&#8212;working room in the project's code&#8212;into an
abundant one.  Normally, all developers work together in the same
sandbox, constructing the same castle.  When someone wants to add a
new drawbridge, but can't convince everyone else that it would be an
improvement, branching makes it possible for her to go to an isolated
corner and try it out.  If the effort succeeds, she can invite the
other developers to examine the result.  If everyone agrees that the
result is good, they can tell the version control system to move
("merge") the drawbridge from the branch castle over to the main
castle.</p><p>It's easy to see how this ability helps collaborative
development.  People need the freedom to try new things without
feeling like they're interfering with others' work.  Equally
importantly, there are times when code needs to be isolated from the
usual development churn, in order to get a bug fixed or a release
stabilized (see <a class="xref" href="stabilizing-a-release.html" title="Stabilizing a Release">&#8222;Stabilizing a Release&#8221;</a> and
<a class="xref" href="release-lines.html" title="Maintaining Multiple Release Lines">&#8222;Maintaining Multiple Release Lines&#8221;</a><span> in
<a class="xref" href="development-cycle.html" title="Rozdzia&#322; 7. Packaging, Releasing, and Daily Development">Rozdzia&#322; 7, <i>Packaging, Releasing, and Daily Development</i></a></span>) without worrying
about tracking a moving target.</p><p>Use branches liberally, and encourage others to use them.  But
also make sure that a given branch is only active for exactly as long
as needed.  Every active branch is a slight drain on the community's
attention.  Even those who are not working in a branch still maintain
a peripheral awareness of what's going on in it.  Such awareness is
desirable, of course, and commit emails should be sent out for branch
commits just as for any other commit.  But branches should not become
a mechanism for dividing the development community.  With rare
exceptions, the eventual goal of most branches should be to merge
their changes back into the main line and disappear.</p></div><div class="sect3" title="Singularity of information"><div class="titlepage"><div><div><h4 class="title"><a name="vc-singularity"></a>Singularity of information</h4></div></div></div><p>Merging has an important corollary: never commit the same change
twice.  That is, a given change should enter the version control
system exactly once.  The revision (or set of revisions) in which the
change entered is its unique identifier from then on.  If it needs to
be applied to branches other than the one on which it entered, then it
should be merged from its original entry point to those other
destinations&#8212;as opposed to committing a textually identical
change, which would have the same effect in the code, but would make
accurate bookkeeping and release management impossible.</p><p>The practical effects of this advice differ from one version
control system to another.  In some systems, merges are special
events, fundamentally distinct from commits, and carry their own
metadata with them.  In others, the results of merges are committed
the same way other changes are committed, so the primary means of
distinguishing a "merge commit" from a "new change commit" is in the
log message.  In a merge's log message, don't repeat the log message
of the original change.  Instead, just indicate that this is a merge,
and give the identifying revision of the original change, with at most
a one-sentence summary of its effect.  If someone wants to see the
full log message, she should consult the original revision.</p><p>The reason it's important to avoid repeating the log message is
that log messages are sometimes edited after they've been committed.
If a change's log message were repeated at each merge destination,
then even if someone edited the original message, she'd still leave
all the repeats uncorrected&#8212;which would only cause confusion
down the road.</p><p>The same principle applies to reverting a change.  If a change
is withdrawn from the code, then the log message for the reversion
should merely state that some specific revision(s) is being reverted,
<span class="emphasis"><em>not</em></span> describe the actual code change that results
from the reversion, since the semantics of the change can be derived
by reading the original log message and change.  Of course, the
reversion's log message should also state the reason why the change is
being reverted, but it should not duplicate anything from the original
change's log message.  If possible, go back and edit the original
change's log message to point out that it was reverted.</p><p>All of the above implies that you should use a consistent syntax
for referring to revisions.  This is helpful not only in log messages,
but in emails, the bug tracker, and elsewhere.  If you're using
CVS, I suggest "<code class="literal">path/to/file/in/project/tree:REV</code>",
where REV is a CVS revision number such as "1.76".  If you're using
Subversion, the standard syntax for revision 1729 is "r1729" (file
paths are not needed because Subversion uses global revision numbers).
In other systems, there is usually a standard syntax for expressing
the changeset name.  Whatever the appropriate syntax is for your
system, encourage people to use it when referring to changes.
Consistent expression of change names makes project bookkeeping much
easier (as we will see in <a class="xref" href="communications.html" title="Rozdzia&#322; 6. Communications">Rozdzia&#322; 6, <i>Communications</i></a> and
<a class="xref" href="development-cycle.html" title="Rozdzia&#322; 7. Packaging, Releasing, and Daily Development">Rozdzia&#322; 7, <i>Packaging, Releasing, and Daily Development</i></a>), and since a lot of the
bookkeeping will be done by volunteers, it needs to be as easy as
possible.</p><p>See also
<a class="xref" href="releases-and-daily-development.html" title="Releases and Daily Development">&#8222;Releases and Daily Development&#8221;</a><span> in
<a class="xref" href="development-cycle.html" title="Rozdzia&#322; 7. Packaging, Releasing, and Daily Development">Rozdzia&#322; 7, <i>Packaging, Releasing, and Daily Development</i></a></span>.</p></div><div class="sect3" title="Authorization"><div class="titlepage"><div><div><h4 class="title"><a name="vc-authz"></a>Authorization</h4></div></div></div><p>Most version control systems offer a feature whereby certain
people can be allowed or disallowed from committing in specific
sub-areas of the repository.  Following the principle that when handed
a hammer, people start looking around for nails, many projects use
this feature with abandon, carefully granting people access to just
those areas where they have been approved to commit, and making sure
they can't commit anywhere else.  (See
<a class="xref" href="committers.html" title="Prawo zapisu">&#8222;Prawo zapisu&#8221;</a><span> in
<a class="xref" href="managing-volunteers.html" title="Rozdzia&#322; 8. Zarz&#261;dzanie ochotnikami">Rozdzia&#322; 8, <i>Zarz&#261;dzanie ochotnikami</i></a></span> for how projects
decide who can commit where.)</p><p>There is probably little harm done by exercising such tight
control, but a more relaxed policy is fine too.  Some projects simply
use an honor system: when a person is granted commit access, even for
a sub-area of the repository, what they actually receive is a password
that allows them to commit anywhere in the project.  They're just
asked to keep their commits in their area.  Remember that there is no
real risk here: in an active project, all commits are reviewed anyway.
If someone commits where they're not supposed to, others will
notice it and say something.  If a change needs to be undone, that's
simple enough&#8212;everything's under version control anyway, so
just revert.</p><p>There are several advantages to the relaxed approach.  First, as
developers expand into other areas (which they usually will if they
stay with the project), there is no administrative overhead to
granting them wider privileges.  Once the decision is made, the person
can just start committing in the new area right away.</p><p>Second, expansion can be done in a more fine-grained manner.
Generally, a committer in area X who wants to expand to area Y will
start posting patches against Y and asking for review.  If someone who
already has commit access to area Y sees such a patch and approves of
it, they can just tell the submitter to commit the change directly
(mentioning the reviewer/approver's name in the log message, of
course).  That way, the commit will come from the person who actually
wrote the change, which is preferable from both an information
management standpoint and from a crediting standpoint.</p><p>Last, and perhaps most important, using the honor system
encourages an atmosphere of trust and mutual respect.  Giving someone
commit access to a subdomain is a statement about their technical
preparedness&#8212;it says: "We see you have expertise to make commits
in a certain domain, so go for it."  But imposing strict authorization
controls says: "Not only are we asserting a limit on your expertise,
we're also a bit suspicious about
your <span class="emphasis"><em>intentions</em></span>."  That's not the sort of
statement you want to make if you can avoid it.  Bringing someone into
the project as a committer is an opportunity to initiate them into a
circle of mutual trust.  A good way to do that is to give them more
power than they're supposed to use, then inform them that it's up to
them to stay within the stated limits.</p><p>The Subversion project has operated on the honor system way for
more than four years, with 33 full and 43 partial committers as of
this writing.  The only distinction the system actually enforces is
between committers and non-committers; further subdivisions are
maintained solely by humans.  Yet we've never had a problem with
someone deliberately committing outside their domain.  Once or twice
there's been an innocent misunderstanding about the extent of
someone's commit privileges, but it's always been resolved quickly and
amiably.</p><p>Obviously, in situations where self-policing is impractical, you
must rely on hard authorization controls.  But such situations are
rare.  Even when there are millions of lines of code and hundreds or
thousands of developers, a commit to any given code module should
still be reviewed by those who work on that module, and they can
recognize if someone committed there who wasn't supposed to.  If
regular commit review <span class="emphasis"><em>isn't</em></span> happening, then the
project has bigger problems to deal with than the authorization system
anyway.</p><p>In summary, don't spend too much time fiddling with the version
control authorization system, unless you have a specific reason to.  It
usually won't bring much tangible benefit, and there are advantages to
relying on human controls instead.</p><p>None of this should be taken to mean that the restrictions
themselves are unimportant, of course.  It would be bad for a project
to encourage people to commit in areas where they're not qualified.
Furthermore, in many projects, full (unrestricted) commit access has a
special status: it implies voting rights on project-wide questions.
This political aspect of commit access is discussed more in <a class="xref" href="consensus-democracy.html#electorate" title="Who Votes?">&#8222;Who Votes?&#8221;</a><span> in
<a class="xref" href="social-infrastructure.html" title="Rozdzia&#322; 4. Social and Political Infrastructure">Rozdzia&#322; 4, <i>Social and Political Infrastructure</i></a></span>.</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"></div><div class="footnote"></div><div class="footnote"></div><div class="footnote"><p><sup>[<a id="ftn.idp6327792" href="#idp6327792" class="para">17</a>] </sup>Patrz <a class="ulink" href="http://cia.vc/stats/vcs" target="_top">http://cia.vc/stats/vcs</a> i
<a class="ulink" href="http://subversion.tigris.org/svn-dav-securityspace-survey.html" target="_top">http://subversion.tigris.org/svn-dav-securityspace-survey.html</a>
aby zobaczy&#263; dowody tego trendu.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp6336736" href="#idp6336736" class="para">18</a>] </sup>Aby pozna&#263; inn&#261; opini&#281; na temat wersjonowania
            plików <code class="filename">configure</code>, przeczytaj wpis na blogu
            Alexey'a Makhotkina zatytu&#322;owany "<em class="citetitle">configure.in and
                version control</em>", dost&#281;pny pod adresem <a class="ulink" href="http://versioncontrolblog.com/2007/01/08/configurein-and-version-control/" target="_top">http://versioncontrolblog.com/2007/01/08/configurein-and-version-control/</a>.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="mailing-lists.html">Poprzedni</a> </td><td width="20%" align="center"><a accesskey="u" href="technical-infrastructure.html">Pocz&#261;tek rozdzia&#322;u</a></td><td width="40%" align="right"> <a accesskey="n" href="bug-tracker.html">Nast&#281;pny</a></td></tr><tr><td width="40%" align="left" valign="top">Listy dyskusyjne </td><td width="20%" align="center"><a accesskey="h" href="index.html">Spis tre&#347;ci</a></td><td width="40%" align="right" valign="top"> Bug Tracker</td></tr></table></div></body></html>
