<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Impacchettamento</title><link rel="stylesheet" type="text/css" href="styles.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="Produrre Software Open Source"><link rel="up" href="development-cycle.html" title="Capitolo 7. Confezione, Rilascio, e Sviluppo Quotidiano"><link rel="prev" href="stabilizing-a-release.html" title="Stabilizzare una Release"><link rel="next" href="testing-and-releasing.html" title="Prove e Rilascio"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Impacchettamento</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="stabilizing-a-release.html">Indietro</a> </td><th width="60%" align="center">Capitolo 7. Confezione, Rilascio, e Sviluppo Quotidiano</th><td width="20%" align="right"> <a accesskey="n" href="testing-and-releasing.html">Avanti</a></td></tr></table><hr></div><div class="sect1" title="Impacchettamento"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="packaging"></a>Impacchettamento</h2></div></div></div><p>La forma canonica per la distribuzione del software libero è il codice sorgente. Questo è vero indipendentemente dal fatto se il codice gira nella forma di sorgente (cioè può essere interpretato come Perl, Python, PHP, ecc..) o prima ha bisogno di esser compilato (come C, C++, Java, ecc..). Con il software compilato, gli utilizzatori probabilmente non compileranno da sè i sorgenti, ma invece installeranno da pacchetti binari per-costruiti
(vedere <a class="xref" href="packaging.html#binary-packages" title="Pacchetti Binari">sezione chiamata «Pacchetti Binari»</a><span>
più avanti in questo capitolo</span>).  Comunque questi pacchetti binari sono tuttavia derivati da una distribuzione principale del sorgente. L'importanza del pacchetto sorgente sta nel definire senza ambiguità la release. Quando il progetto distribuisce la, quello che vuol dire specificatamente è &#8220;I tre files del codice sorgente, che quando compilati (se necessario) e installati, producono la Scanley 2.5.0."</p><p>C' è uno standard ragionevolmente rigido su come devono presentarsi le release sorgenti. Si potrebbero vedere occasionalmente delle deviazioni da questo standard, me sono l'eccezione, non la regola. A meno che non ci sia una convincente ragione per fare diversamente, anche il vostro progetto dovrebbe seguire questo standard.</p><div class="sect2" title="Il Formato"><div class="titlepage"><div><div><h3 class="title"><a name="packaging-format"></a>Il Formato</h3></div></div></div><p>Il codice sorgente dovrebbe essere inviato in formati standard per trasportare alberi di directory. Per i sistemi operativi Unix e pseudo Unix, la convenzione è usare il formato TAR, compresso da <span class="command"><strong>compress</strong></span>, <span class="command"><strong>gzip</strong></span>,
<span class="command"><strong>bzip</strong></span> o <span class="command"><strong>bzip2</strong></span>  che sembra fare la compressione anche bene, in modo che non c'è bisogno di comprimere l'archivio dopo averlo creato.</p><div class="sidebar" title="TAR Files"><a name="packaging-tar"></a><div class="titlepage"><div><div><p class="title"><b>TAR Files</b></p></div></div></div><p><em class="firstterm">TAR</em> stands for "Archivio per nastro", perché il formato TAR rappresenta l'albero di directory come un flusso di dati lineari, che lo rende ideale per salvare l'albero di directory su nastro. La stessa proprietà lo rende anche lo standard per distribuire gli alberi di directory come un singolo file. Produrre files tar 
   (o <em class="firstterm">tarballs</em>) è molto facile.  Su qualche sistema il comando tar può produrre un archivio compresso da sé; in altri è usata un programma di compressione a parte. </p></div></div><div class="sect2" title="Nome E Disposizione"><div class="titlepage"><div><div><h3 class="title"><a name="packaging-name-and-layout"></a>Nome E Disposizione</h3></div></div></div><p>Il nome del pacchetto dovrebbe consistere nel nome del software, più il numero di release, più il suffisso di formato per il tipo di archivio. Per esempio, Scanley 2.5.0, impacchettato per Unix che usa la compressione GNU Zip (gzip), apparirebbe come questo:</p><div class="informalexample"><div class="literallayout"><p>scanley-2.5.0.tar.gz</p></div></div><p> o per Windows che usa la compressione zip:</p><div class="informalexample"><div class="literallayout"><p>scanley-2.5.0.zip</p></div></div><p>Ciascuno di questi archivi, quando è estratto, dovrebbe creare un unico albero di directory chiamato <code class="filename">scanley-2.5.0</code> nella directory corrente. Sotto la nuova directory, il codice sorgente dovrebbe essere sistemato in una disposizione pronta per la compilazione (se c'è bisogno di compilazione) e per l'installazione. Nel livello più alto dell'albero delle directory ci dovrebbe essere un file di testo piano <code class="filename">README</code> che spieghi ciò che il software fa e quale release è, e che dà le indicazioni per altre risorse, come il sito del progetto, altri file di interesse, ecc.. Fra questi altri files ci dovrebbe essere un file fratello
<code class="filename">INSTALL</code>
del file <code class="filename">README</code> che dia istruzione su come costruire e installare il software per tutti i sistemi operativi che supporta. Come menzionato in
<a class="xref" href="license-quickstart.html#license-quickstart-applying" title="Come Applicare Una Licenza Al Vostro Software">sezione chiamata «Come Applicare Una Licenza Al Vostro Software»</a><span>
in <a class="xref" href="getting-started.html" title="Capitolo 2. Partenza">Capitolo 2, <i>Partenza</i></a></span>, ci dovrebbe essere anche un file <code class="filename">COPYING</code> or <code class="filename">LICENSE</code>
che fornisca i termini di distribuzione.</p><p>Ci dovrebbe essere anche un file <code class="filename">CHANGES</code>
(a volte chiamato <code class="filename">NEWS</code>), che spieghi ciò che c'è di nuovo in quella release.  Il file <code class="filename">CHANGES</code> accumula le liste dei cambiamenti per tutte le releases, in ordine cronologico inverso, in modo che la lista per quella release appaia in cima al file. A completare la lista c'è usualmente l'ultima cosa fatta per stabilizzare il ramo di release; alcuni progetti scrivono la lista un pò alla volta mentre si sviluppano, altri preferiscono salvarla alla fine di tutto, e hanno una persona a scriverla, che prende le informazioni setacciando i log del controllo di versione. La lista appare come qualcosa del genere:</p><pre class="screen">
Version 2.5.0
(20 December 2004, da /rami/2.5.x)
http://svn.scanley.org/repos/svn/tags/2.5.0/

 New features, enhancements:
    * Added regular expression queries (issue #53)
    * Added support for UTF-8 and UTF-16 documents
    * Documentation translated into Polish, Russian, Malagasy
    * ...

 Bugfixes:
    * fixed reindexing bug (issue #945)
    * fixed some query bugs (issues #815, #1007, #1008)
    * ...
</pre><p>L'elenco può facilmente essere tanto lungo quanto è necessario, ma non vi preoccupate di includere ogni piccola correzione di bug e accrescimento di funzionalità. Il suo proposito è solamente dare agli utilizzatori una visione d'insieme di quale sarebbe il guadagno ad aggiornare alla nuova release. Infatti, la  lista dei cambiamenti è abitualmente inclusa nelle email di annuncio (vedere
<a class="xref" href="testing-and-releasing.html" title="Prove e Rilascio">sezione chiamata «Prove e Rilascio»</a><span>
più avanti in questo capitolo</span>), in modo che la scriviate con il pubblico nella mente.</p><div class="sidebar" title="CHANGES A Confronto Con il Changelog"><a name="changelog"></a><div class="titlepage"><div><div><p class="title"><b>CHANGES A Confronto Con il Changelog</b></p></div></div></div><p>Tradizionalmente un file chiamato Changelog elenca ogni cambiamento apportato a un progetto cioè ogni revisione inviata al sistema di controllo di versione. Ci sono vari formati per il file Cahngelog; i dettagli dei formati non sono importanti qui, in quanto essi contengono tutti la stessa informazione: la data del cambiamento, il suo autore, e un breve sommario (o giusto un messaggio di log per quel cambiamento).</p><p>Un file <code class="filename">CHANGES</code> è differente.  Anch'esso è una lista dei cambiamenti, ma solo quelli ritenuti importanti da vedere da parte di un certo pubblico, e con metadati come la data esatta e l'autore spogli. Per evitare confusioni non usate termini in modo scambievole. Alcuni progetti usano &#8220;NEWS&#8221; invece di  "CHANGES"; sebbene ciò evita la possibilità di di una confusione con &#8220;Changelog&#8221;, è un po' un termine improprio, poiché un file CHANGES conserva un sacco di informazioni sui cambiamenti per tutte le releases, e quindi un sacco di vecchie notizie in aggiunta alle nuove notizie in cima.</p><p>I files Changelog possono lentamente scomparire comunque. Essi erano utili nei giorni in cui in cui il CVS era l'unica scelta per un sistema di controllo di versione, perché i dati sui cambiamenti non erano facilmente estraibili da CVS. Comunque, con i più recenti sistemi di controllo della versione, i dati che si usavano tenere nel Changelog possono essere richiesti al deposito del controllo della versione in ogni momento, rendendo inutile per il progetto tenere un file statico contenente quei dati nei fatti peggiore che l'inutilità, poiché il Changelog duplicherebbe i messaggi di log già immagazzinati nel deposito.</p></div><p>Usualmente ci sono poche differenze, per esempio perché il pacchetto contiene alcuni file generati necessari per la compilazione e la configurazione (vedere
<a class="xref" href="packaging.html#packaging-build-install" title="Compilazione e Installazione">sezione chiamata «Compilazione e Installazione»</a><span>
più avanti in questo capitolo</span>), o perché contiene un software di terze parti di cui il progetto non fa manutenzione, ma ciò è richiesto e ciò è probabile che gli utilizzatori non abbiano.
Ma anche se l'albero distribuito corrispondesse esattamente ad alcuni alberi di sviluppo nel deposito del controllo di versione, la distribuzione stessa non sarebbe un copia funzionante (vedere <a class="xref" href="vc.html#vc-vocabulary-working-copy"><em class="firstterm">copia di lavoro</em></a>).
Si suppone che la release un punto di riferimento statico una particolare, immutabile configurazione dei files sorgenti. Se essa fosse una copia funzionante, il danno sarebbe che gli utilizzatori potrebbero aggiornarla, e successivamente pensare di avere ancora la release quando nei fatti egli ha qualcosa di differente.</p><p>Ricordate che il pacchetto è lo stesso indipendentemente dalla confezione. La release cioè la precisa entità riferita a quando qualcuno dice  "Scanley 2.5.0"&#8212;è l'albero creato estraendo un file zip o tar. Così il progetto potrebbe offrire tutti questi per il download:</p><div class="informalexample"><div class="literallayout"><p>scanley-2.5.0.tar.bz2<br>
scanley-2.5.0.tar.gz<br>
scanley-2.5.0.zip</p></div></div><p>...ma l'albero sorgente estraendoli deve essere lo stesso. Quell'albero sorgente è la distribuzione.; la forma in cui è scaricato è un pura questione di convenienza. Certe differenze secondarie fra i pacchetti sorgente sono ammissibili: per esempio, nel pacchetto Windows i file di testo devono avere un fine linea con CRLF (Carriage Return and Line Feed), mentre il pacchetto Unix deve usare giusto LF. Gli alberi possono essere sistemati in maniera poco differente fra i pacchetti destinati a sistemi operativi differenti, anche, se questi sistemi operativi richiedono diversi tipi sistemazione per la compilazione. Comunque, queste sono di base le tutte le trasformazioni secondarie. I file sorgenti di base devono essere gli stessi nell'impacchettamento di una data release. </p><div class="sect3" title="Mettere le maiuscole o non metterle"><div class="titlepage"><div><div><h4 class="title"><a name="release-capitalization"></a>Mettere le maiuscole o non metterle</h4></div></div></div><p>Quando ci si riferisce a un progetto col nome, la gente generalmente lo nomina con la maiuscola come un nome proprio. E mette le maiuscola agli acronimi, se ce ne sono ecc.. Se la maiuscola debba essere usata nel pacchetto tocca al progetto
<code class="filename">Scanley-2.5.0.tar.gz</code> o
<code class="filename">scanley-2.5.0.tar.gz</code> sarebbero ottimi, per esempio (io preferisco personalmente la seconda, perché non mi piace che la gente pigi il tasto shift, ma un gran numero di progetti inviano pacchetti con la maiuscola). La cosa importante è che le directory che si creano estraendo il pacchetto tar usino anche la maiuscola. Non si dovrebbero essere sorprese: l'utilizzatore dovrebbe essere di predire con perfetta accuratezza il nome della directory che so creerà quando estrarrà una distribuzione.</p></div><div class="sect3" title="Pre-releases"><div class="titlepage"><div><div><h4 class="title"><a name="release-prereleases"></a>Pre-releases</h4></div></div></div><p>Quando inviate una pre-release o una candidate release il qualificatore è con esattezza una parte del numero di release,
così includetelo nel nome del pacchetto. Per esempio, la sequenza ordinata di releases alfa e beta date prima in
<a class="xref" href="development-cycle.html#release-number-components" title="I Componenti del Numero di Rilascio">sezione chiamata «I Componenti del Numero di Rilascio»</a> dovrebbero apparire nel nome del pacchetto come:</p><div class="informalexample"><div class="literallayout"><p>scanley-2.3.0-alpha1.tar.gz<br>
scanley-2.3.0-alpha2.tar.gz<br>
scanley-2.3.0-beta1.tar.gz<br>
scanley-2.3.0-beta2.tar.gz<br>
scanley-2.3.0-beta3.tar.gz<br>
scanley-2.3.0.tar.gz</p></div></div><p>La prima si estrarrebbe in una directory chiamata <code class="filename">scanley-2.3.0-alpha1</code>, la seconda nella
<code class="filename">scanley-2.3.0-alpha2</code>, e così via.</p></div></div><div class="sect2" title="Compilazione e Installazione"><div class="titlepage"><div><div><h3 class="title"><a name="packaging-build-install"></a>Compilazione e Installazione</h3></div></div></div><p>Per software che richiede compilazione e installazione dal sorgente, si sono usualmente delle procedure standard che si presume gli utilizzatoti esperti siano capaci di seguire. Per esempio, per programmi scritti in C, C++, o certi altri linguaggi compilati, lo standard per sistemi tipo Unix e che l'utilizzatore batta:</p><pre class="screen">
   $ ./configure
   $ make
   # make install
</pre><p>Il primo comando individua come sa l'ambiente e prepara il processo di allestimento (ma non installa), e il secondo comando installa sul sistema. I primi due comandi sono impartiti come utente normale, il terzo come radice. Per maggiori dettagli su come settare il sistema, vedere l'eccellente libro <em class="citetitle">GNU Autoconf, Automake, and
Libtool</em> di Vaughan, Elliston, Tromey, e Taylor.  Esso è pubblicato su carta da New Riders, e il suo contenuto è anche disponibile in forma freeware online a
<a class="ulink" href="http://sources.redhat.com/autobook/" target="_top">http://sources.redhat.com/autobook/</a>.</p><p>Questo non è il solo standard, sebbene sia uno dei più diffusi. Il sistema di allestimento Ant (<a class="ulink" href="http://ant.apache.org/" target="_top">http://ant.apache.org/</a>) sta guadagnando popolarità, specialmente con progetti scritti in Java, ed ha le sue proprie procedure standard per l'allestimento e l'installazione. Inoltre, certi linguaggi di programmazione come Perù e Pathos, raccomandano che, per la maggioranza del programmi scritti in quel linguaggio sia usato lo stesso metodo (per esempio moduli Perl usano il comando <span class="command"><strong>perl Makefile.PL</strong></span>).  Se non è ovvio per voi quale debba essere lo standard applicabile per il vostro progetto, chiedete a uno sviluppatore esperto; potete con sicurezza accettare che <span class="emphasis"><em>qualche</em></span> standard si applica, anche se non sapete quale venga prima.</p><p>Quale che sia lo standard adatto per il vostro progetto, non deviate da esso a meno che non dobbiate certamente farlo. Le procedure standard per l'installazione sono in pratica dei responsi automatici a stimoli specifici per un sacco di amministratori di sistema attualmente. Se essi vedono richieste di aiuto be note documentate nel file, ciò istantaneamente genera in essi la credenza che il vostro progetto è generalmente fuori dalle convenzioni, e anche che sarebbe riuscito bene in altre cose.  Anche, come discusso in
<a class="xref" href="getting-started.html#downloads" title="Downloads">sezione chiamata «Downloads»</a><span> in
<a class="xref" href="getting-started.html" title="Capitolo 2. Partenza">Capitolo 2, <i>Partenza</i></a></span>, avere una procedura standard
di allestimento piace ai potenziali sviluppatori.</p><p>Su Windows gli standards per l'allestimento e per l'installazione sono un po' meno fissi. Per progetti che richiedono la compilazione, la convenzione generale sembra essere inviare un albero che si può sistemare in un modello di  area di lavoro/progetto dell'ambiente di sviluppo standard di Microsoft (Developer Studio, Visual Studio, VS.NET, MSVC++, ecc...). A seconda della natura del vostro software, può essere possibile offrire una opzione di allestimento su Windows via ambiente Cygwin.
(<a class="ulink" href="http://www.cygwin.com/" target="_top">http://www.cygwin.com/</a>)  E certamente, se state usando un linguaggio o un framework di programmazione che viene con le sue convenzioni di allestimento e installazione, per esempio Phiton o Perl dovreste semplicemente usare quello che sia il metodo standard per quel framework, su Windows, Unix, Mac OS X, o ogni altro sistema operativo.</p><p>Siate disponibili a metterci un sacco di impegno extra per rendere il vostro progetto conforme agli standards di rilievo per l'allestimento e l'installazione. L'allestimento e l'installazione sono una fase di ingresso: è giusto che le cose diventino più difficili dopo di essi, se è fuori discussione che lo siano, ma sarebbe un disonore nei confronti degli utilizzatori o degli sviluppatori se la prima interazione col software richiedesse passi imprevisti.</p></div><div class="sect2" title="Pacchetti Binari"><div class="titlepage"><div><div><h3 class="title"><a name="binary-packages"></a>Pacchetti Binari</h3></div></div></div><p>Sebbene la release formale sia un pacchetto di codice sorgente, la maggior parte degli utilizzatori  installeranno da pacchetti binari, sia che siano forniti dal meccanismo di distribuzione del software del sistema operativo, sia che siano ottenuti manualmente dal sito del progetto o da terze parti. Qui &#8220;binario&#8221; non significa necessariamente  &#8220;compilato&#8221;; significa giusto una forma pre-configurata del pacchetto che permette a un utilizzatore di installarla sul proprio computer senza passare attraverso le solite procedure di allestimento e installazione. Su RedHat GNU/Linux, è il sistema RPM; su Debian GNU/Linux, È il sistema
APT (<code class="filename">.deb</code>); su Windows, di solito i files 
<code class="literal">.MSI</code> il file autoistallante
<code class="literal">.exe</code>.</p><p>Se il file binario sia assemblato da gente strettamente associate al progetto, o da distanti terze parti, gli utilizzatori tendono a <span class="emphasis"><em>considerarli</em></span> equivalenti alle releases ufficiali del progetto, e depositeranno i problemi nel tracciatore di bug apposito per il comportamento dei pacchetti binari. Quindi, è nell'interesse del progetto fornire pacchetti con chiare linee guida, e lavorare moltissimo con esse per assicurarsi che quello che producono rappresenti il software in modo pulito e accurato.</p><p>La cosa principale che gli impacchettatori hanno bisogno di sapere è che essi dovrebbero basare sempre i loro pacchetti binari su una release ufficiale originale. Talvolta gli impacchettatori son tentati di tirar fuori una recente incarnazione del codice dal deposito, o di includervi cambiamenti selezionati che furono inviati dopo che la release fu fatta, per fornirli agli utilizzatori con certe correzioni di bugs o altri miglioramenti. Chi fa i pacchetti pensa di star facendo un favore ai suoi utilizzatori nel dare loro codice più recente, ma in realtà questa pratica causa una gran quantità di confusione. I progetti sono preparati a ricevere rapporti di bugs trovati nelle versioni rilasciate, e di bugs trovati nel recente tronco e nel codice del ramo maggiore (cioè trovati da gente lì apposta per far girare codice a rischio di stabilità e produttività).
Quando un bug proviene da queste fonti, il risponditore sarà spesso capace di confermare che è noto che quel bug è presente in quell'istantanea, e forse che da allora è stato corretto e che l'utente dovrebbe aggiornare o aspettare la successiva release. Se esso è un precedente bug non noto, l'avere l'esatta release fa si che sia più facile riprodurlo e più facile classificarlo nel tracciatore.</p><p> progetti non sono preparati, comunque, a ricevere rapporti di bugs basati su un mezzo intermedio non specifico o su versioni ibride. Tali bugs possono essere difficili da riprodurre; inoltre possono essere dovuti a interazioni non previste in cambiamenti isolati introdotti da successivi sviluppi, quindi causano cattivi comportamenti  di cui gli sviluppatori del progetto non dovrebbero essere incolpati. Ho visto una sconcertante gran quantità di tempo sprecata perché un bug era       <span class="emphasis"><em>absent</em></span> quando avrebbe dovuto essere presente: qualcuno stava facendo girare una versione leggermente modificata, basata (ma non identica) su una release ufficiale, e quando i bug predetto non si verificava ognuno doveva scavare un fossato per capire il perché. </p><p>Tuttavia  quelle erano circostanze in cui chi faceva il pacchetto insisteva sul fatto che quelle modifiche alla release originale erano necessarie. Chi faceva i pacchetti avrebbe dovuto essere incoraggiato a tirar fuori questo con gli sviluppatori del progetto e a spiegare i suoi piani. Essi possono trovare consenso, ma mancando questo, almeno avranno notificato al progetto le loro intenzioni, così che il progetto può stare attento a insoliti rapporti di bugs. Gli sviluppatori possono rispondere mettendo un disclaimer sul sito del progetto, e possono chiedere a chi fa i pacchetti di fare la stessa cosa nel posto appropriato, di modo che gli utilizzatori di quel pacchetto binario sappiano che ciò che stanno prendendo non è esattamente la stessa cosa di ciò che il progetto ha rilasciato. Non ci deve essere animosità in questa situazione, sebbene purtroppo spesso ce ne sia. E' solo che chi fa i pacchetti ha degli obiettivi leggermente differenti da quelli degli sviluppatori. Coloro che fanno i pacchetti vogliono che i loro utilizzatori incontrino le migliori funzionalità. Gli sviluppatori vogliono anche questo, certo, ma hanno anche bisogno di essere sicuri di conoscere quali versioni del software ci sono in giro, in modo da poter ricevere rapporti di bugs intellegibili e garantire compatibilità. A volte i loro obiettivi sono in conflitto. Quando ciò avviene è bene avere in mente il fatto che il progetto non ha nessun controllo su coloro che fanno i pacchetti e che i vincoli degli obblighi funzionano in entrambe le direzioni. E' vero che il progetto sta facendo un favore a chi fa i pacchetti semplicemente producendo il software. Ma anche quelli che fanno i pacchetti stanno facendo un favore al progetto e si stanno accollando un lavoro non eccitante per rendere il software più largamente disponibile, spesso per ordine di rilievo. E' bene non essere d'accordo con gli impacchettatori, ma non è bene offenderli. Giusto cercate una soluzione alle cose meglio che potete.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="stabilizing-a-release.html">Indietro</a> </td><td width="20%" align="center"><a accesskey="u" href="development-cycle.html">Risali</a></td><td width="40%" align="right"> <a accesskey="n" href="testing-and-releasing.html">Avanti</a></td></tr><tr><td width="40%" align="left" valign="top">Stabilizzare una Release </td><td width="20%" align="center"><a accesskey="h" href="index.html">Partenza</a></td><td width="40%" align="right" valign="top"> Prove e Rilascio</td></tr></table></div></body></html>
