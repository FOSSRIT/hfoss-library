<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Le Releases e Lo Sviluppo Quotidiano</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="sect1" title="Le Releases e Lo Sviluppo Quotidiano"><div class="titlepage"><div><div><h1 class="title"><a id="releases-and-daily-development"/>Le Releases e Lo Sviluppo Quotidiano</h1></div></div></div><p>Il mantenimento di releases parallele simultaneamente ha ripercussioni su come vien fatto lo sviluppo quotidiano. In particolare ciò rende obbligatoria una disciplina che sarebbe raccomandata comunque: ottenere che ogni invio sia un singolo cambiamento logico, e non mescoli nello stesso invio cambiamenti non correlati. Se un cambiamento è troppo grande o troppo dirompente se fatto in un unico invio, dividetelo in N invii, dove ogni invio sia una ben ripartita sottosezione del cambiamento completo, e non includa nulla di non correlato al cambiamento completo.</p><p>Qui c'è un esempio di invio mal concepito:</p><pre class="screen">
------------------------------------------------------------------------
r6228 | jrandom | 2004-06-30 22:13:07 -0500 (Wed, 30 Jun 2004) | 8 lines

Correzione del problema #1729: Rebdere l'indicizzzazione gradevole 
avvisa l'utente quando un file sta cambiando mentre viene indicizzato.

* ui/repl.py
  (ChangingFile): Nuova classe di eccezione.
  (DoIndex): Gestire la nuova eccezione.

* indexer/index.py
  (FollowStream): Far comparire la nuova eccezione se il file sta 
   cambiando durente l'indicizzazione.
  (BuildDir): Senza correlazione, rimuovere i commenti obsoleti,
  riformattare del codice, e correggere la ricerca degli errori
  mentre si crea una directory.

Altre pulizie non correlate:

* www/index.html: Corregge alcuni refusi, fissa la data della nuova release.
------------------------------------------------------------------------
</pre><p>Il problema con esso diventa evidente non appena qualcuno ha bisogno di fare il port della <code class="function">BuildDir</code> ricerca e correzione degli errori su un ramo per una release di manutenzione in arrivo. Chi fa il port non vuole nessuno degli altri cambiamenti per esempio la correzione al problema #1729 non è stata approvata affatto per il ramo di manutenzione e le modifiche del
<code class="filename">index.html</code> sarebbero semplicemente irrilevanti qui. Ma egli non riesce ad afferrare il cambiamento alla
<code class="function">BuildDir</code> attraverso la funzionalità di unione dello strumento del controllo di versione, perché al sistema di controllo di versione era stato detto che il cambiamento è logicamente raggruppato con tutte quelle altre cose non correlate. Infatti, il problema dovrebbe diventare evidente anche prima dell'unione. Il semplice elencare i cambiamenti per il voto diventerebbe problematico: invece di dare solo il numero di revisione, il proponente dovrebbe fare una speciale patch o cambiare ramo per isolare la porzione di invio che viene proposta. Il che sarebbe un sacco di lavoro da sopportare per gli altri, e tutto perché chi fa l'invio originale non potrebbe essere seccato a suddividere le cose in gruppi logici.</p><p>In realtà quell'invio avrebbe dovuto essere
<span class="emphasis"><em>quattro</em></span> separati invii: uno per correggere il problema #1729, un altro per rimuovere i commenti obsoleti e riformattare il codice nella
<code class="function">BuildDir</code>, un altro per correggere la ricerca degli errori nella
<code class="function">BuildDir</code>, e infine uno per modificare l'
<code class="filename">index.html</code>.  Il terzo di questi invii sarebbe l'unico proposto per il ramo di mantenimento della release.</p><p>Certo, la stabilizzazione della release non è l'unica ragione per cui è desiderabile avere che ogni invio sia l'unico cambiamento logico. Psicologicamente un invio semanticamente unificato è più facile da revisionare, e più facile da riportare al punto di partenza se necessario (in alcuni sistemi di controllo della versione riportare al punto di partenza è effettivamente una speciale forma di unione, comunque). Un piccolo addestramento aperto sulla parte di ognuno può evitare al progetto un sacco di mal di testa più tardi.</p><div class="sect2" title="Pianificare le Releases"><div class="titlepage"><div><div><h2 class="title"><a id="planning"/>Pianificare  le Releases</h2></div></div></div><p>Un campo in cui i progetti open source si sono differenziati dai progetti proprietari è la pianificazione delle releases. I progetti proprietari di solito hanno scadenze più decise. A volte ciò avviene perché i clienti sono stati avvisati che un aggiornamento sarebbe disponibile per una certa data, perché c'è bisogno che la nuova release sia coordinata con altri impegni di marketing, o perché il capitalista che rischia, che ha investito in tutta la cosa ha bisogno di vedere alcuni risultati prima di mettervi dentro altri finanziamenti. I progetti open source, invece, erano fino a tempi recenti in  gran parte motivati da dilettantismo nel senso più letterale: erano scritti per amore di essi. Nessuno sentiva il bisogno di inviare prima che tutte le funzionalità fossero pronte, e perché avrebbero dovuto? Non era incredibile che il lavoro di ognuno fosse senza indugi. </p><p>Al giorno d'oggi, molti progetti open source sono finanziati dalle compagnie, e sono di conseguenza influenzati dalla cultura della scadenza delle compagnie. Questo è sotto molti aspetti una buona cosa, ma può creare dei conflitti fra le priorità degli sviluppatori pagati e quelle di coloro che stanno offrendo volontariamente il loro tempo. Questi conflitti avvengono spesso sul come e quando programmare le releases. Gli
sviluppatori salariati che sono sotto pressione vorranno naturalmente scegliere una data in cui avverrà la release e ottenere che l'attività di ognuno ci si allinei. Ma i volontari possono avere un'altra agenda forse funzionalità che vogliono completare o qualche prova che vogliono fare a riguardo —essi ritengono che la release dovrebbe aspettare.</p><p>Non c'è una soluzione che vada bene sempre a questo problema, tranne la discussione e il compromesso, certo. Ma potete rendere minimi la frequenza e i grado di attrito che si verifica, separando
<span class="emphasis"><em>la vita</em></span> che ci si ripropone per una data release dalla data in cui deve uscire. Cioè, cercare di indirizzare la discussione verso l'argomento di quali releases il progetto sta creando nel futuro a medio termine, e su quali funzionalità ci saranno in esse, senza prima fare nessuna menzione delle date, eccetto che approssimative congetture con largo margine di errore.<sup>[<a id="idp8705840" href="#ftn.idp8705840" class="footnote">21</a>]</sup>.  Fissando prima gli insiemi di funzionalità, riducete la complessità delle discussione incentrata su una singola release, e quindi ne migliorate la prevedibilità. Questo crea anche una tendenza inerziale contro chiunque proponga di espandere la definizione della release aggiungendo nuove funzionalità e altre complicazioni. Se i contenuti della release sono del tutto ben definiti, è onere di chi propone giustificarne l'espansione, anche se la data della release non può essere ancora fissata.</p><p>Nella biografia multi volume di Thomas Jefferson,
<em class="citetitle">efferson e il suo Tempo</em>, Dumas Malone racconta la storia di come Jefferson gestì il primo meeting tenutosi per decidere l'organizzazione della futura Università della Virginia. L'Università aveva avuto l'idea di Jefferson al primo posto, ma (come è nel caso di ogni luogo, non solo nei progetti open source, molti altri gruppi erano saliti sul palco rapidamente, ognuno coi propri interessi e agende. Quando essi si adunarono in quel primo meeting per parlare delle cose, Jefferson si assicurò con i disegni di una meticolosa architettura preparata, budgets dettagliati per la costruzione e per l'operatività, un programma di studi proposto, e i nomi delle specifiche facoltà che voleva importare dell'Europa. Nessun altro nella sala era così preparato anche lontanamente; e finalmente l'Università fu fondata più o meno in accordo con i suoi piani. Il fatto che  la costruzione andò di molto oltre il budget, e molte delle sue idee invece no, per molte ragioni, si risolse alla fine, in cui Jefferson conosceva perfettamente le cose che sarebbero accadute. Il suo proposito fu strategico: mettersi in mostra nel meeting con qualcosa di così concreto che chiunque altro avrebbe fallito nella parte di proporre semplicemente modifiche ad esso, cosicché il disegno complessivo, e quindi il programma, sarebbe stato in modo grezzo quello che voleva.</p><p>Nel caso di un progetto di software libero non c'è un singolo “meeting”, ma invece una serie di piccole proposte fatte per la maggior parte per mezzo del tracciatore di problemi. Ma se avete un certa credibilità nel progetto per incominciare, e partite con l'assegnare varie funzionalità, accrescimenti, e bugs alla release obiettivo nel tracciatore di problemi, in accordo con quelche piano complessivo annunciato, la gente per la maggior parte andrà insieme a voi. Una volta che avete ottenuto che le cose siano sistemate più o meno come volete, la conversazione sulle
<span class="emphasis"><em>date</em></span> delle releases andrà avanti in modo più regolare.</p><p>E' cruciale, certo, non presentare mai una decisione individuale come scritta nella pietra. Nei commenti associati all'assegnamento di un problema a una specifica futura release, provocate una discussione, e siate genuinamente desiderosi di essere persuasi ogni volta che è possibile. Non esercitate mai il controllo con lo scopo di esercitare solamente il controllo: più a fondo gli altri parteciperanno al processo di pianificazione delle releases (vedere
<a class="xref" href="ch08s02.html" title="Suddividete i Compiti di Management e i Compiti Tecnici">sezione chiamata «Suddividete i Compiti di Management e i Compiti Tecnici»</a><span> in
<a class="xref" href="ch08.html" title="Capitolo 8. Gestire i Volontari">Capitolo 8, <em>Gestire i Volontari</em></a></span>), più facile sarà il persuaderli a condividere le vostre priorità sui problemi che contano veramente per voi. </p><p>L'altro modo in cui il progetto può smorzare le tensioni sulla pianificazione delle release è fare releases molto spesso. Quando c'è molto tempo fra le releases, l'importanza di ogni singola releases è amplificato nella mente di ognuno; le persone si sentono così tanto più annientate quando il loro codice non ce la fa ad entravi, perché sanno quanto tempo ci vorrà per il prossimo cambiamento. A seconda della complessità del processo di rilascio e della natura del vostro progetto, qualcosa come tre o sei mesi è il giusto intervallo di solito fra le releases, sebbene le linee di manutenzione possono far uscire micro releases un po' più spesso, se c'è bisogno di esse.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.idp8705840" href="#idp8705840" class="para">21</a>] </sup>Per un approccio alternativo potreste voler leggere la tesi di Martin Michlmayr's Ph.D. <em class="citetitle">Quality
Il Miglioramento Della Qualità Nei Progetti Volontari di Software Open Source:
Esplorazione dell'Impatto della Gestione Delle Releases</em>
(<a class="ulink" href="http://www.cyrius.com/publications/michlmayr-phd.html">http://www.cyrius.com/publications/michlmayr-phd.html</a>).
Si tratta dell'uso dei processi di rilascio basati sul tempo, in opposizione a quelli basati sulle funzionalità. Michlmayr fece anche un discorso presso Google sull'argomento, disponibile su Google video a
<a class="ulink" href="http://video.google.com/videoplay?docid=-5503858974016723264">http://video.google.com/videoplay?docid=-5503858974016723264</a>.</p></div></div></div></body></html>
